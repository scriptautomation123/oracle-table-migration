-- Oracle Comprehensive Test DDL - Reorganized for Proper DDL Order
-- =====================================================================
-- Self-contained script to create complete Oracle test environment
-- Proper order: Tables -> Indexes -> Constraints -> Data -> Statistics -> Grants
--
-- Features: Non-partitioned, RANGE, LIST, HASH, INTERVAL, Composite partitioning
-- Includes: Identity columns, LOBs, complex indexes, constraints, foreign keys,
--          check constraints, composite indexes, referential integrity
--
-- Usage: Open in SQL Developer or Toad and run as script - no parameters needed
-- =====================================================================

-- ==========================================
-- SCRIPT SETTINGS
-- ==========================================
SET ECHO OFF
SET FEEDBACK ON
SET SERVEROUTPUT ON SIZE 1000000
SET VERIFY OFF
SET TIMING ON
WHENEVER SQLERROR CONTINUE

-- ==========================================
-- CONFIGURATION VARIABLES (HARDCODED)
-- ==========================================
DEFINE owner_schema = APP_DATA_OWNER
DEFINE app_schema = APP_DATA_USER
DEFINE owner_password = OraclePass123
DEFINE app_password = AppPass123
DEFINE tablespace_name = USERS

PROMPT Script Configuration:
PROMPT - Owner Schema: &owner_schema
PROMPT - App Schema: &app_schema
PROMPT - Tablespace: &tablespace_name
PROMPT

PROMPT ========================================
PROMPT Oracle Comprehensive Test Environment
PROMPT Creating schemas, roles, tables, and data
PROMPT ========================================

-- ==========================================
-- SCHEMA AND ROLE CREATION
-- ==========================================

-- Drop existing users and roles (ignore errors if they don't exist)
BEGIN
    EXECUTE IMMEDIATE 'DROP USER &owner_schema CASCADE';
    DBMS_OUTPUT.PUT_LINE('✓ Dropped user &owner_schema');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &owner_schema user did not exist or could not be dropped');
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP USER &app_schema CASCADE';
    DBMS_OUTPUT.PUT_LINE('✓ Dropped user &app_schema');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &app_schema user did not exist or could not be dropped');
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP ROLE &owner_schema._DML_ROLE';
    DBMS_OUTPUT.PUT_LINE('✓ Dropped role &owner_schema._DML_ROLE');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &owner_schema._DML_ROLE did not exist or could not be dropped');
END;
/

BEGIN
    EXECUTE IMMEDIATE 'DROP ROLE &owner_schema._EX_ROLE';
    DBMS_OUTPUT.PUT_LINE('✓ Dropped role &owner_schema._EX_ROLE');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &owner_schema._EX_ROLE did not exist or could not be dropped');
END;
/

-- Create owner schema
CREATE USER &owner_schema IDENTIFIED BY "&owner_password"
  DEFAULT TABLESPACE &tablespace_name
  TEMPORARY TABLESPACE TEMP
  QUOTA UNLIMITED ON &tablespace_name;

GRANT CONNECT, RESOURCE TO &owner_schema;
GRANT CREATE VIEW TO &owner_schema;
GRANT CREATE PROCEDURE TO &owner_schema;
GRANT CREATE SEQUENCE TO &owner_schema;
GRANT CREATE TRIGGER TO &owner_schema;
GRANT CREATE SYNONYM TO &owner_schema;

-- Create app schema
CREATE USER &app_schema IDENTIFIED BY "&app_password"
  DEFAULT TABLESPACE &tablespace_name
  TEMPORARY TABLESPACE TEMP
  QUOTA 0 ON &tablespace_name;

GRANT CONNECT TO &app_schema;
GRANT CREATE SYNONYM TO &app_schema;

PROMPT ✓ Created &owner_schema (owner schema)
PROMPT ✓ Created &app_schema (app schema)

-- Create DML role
DECLARE
BEGIN
    EXECUTE IMMEDIATE 'CREATE ROLE &owner_schema._DML_ROLE';
    DBMS_OUTPUT.PUT_LINE('✓ Created role: &owner_schema._DML_ROLE');
END;
/

-- Create EXECUTE role
DECLARE
BEGIN
    EXECUTE IMMEDIATE 'CREATE ROLE &owner_schema._EX_ROLE';
    DBMS_OUTPUT.PUT_LINE('✓ Created role: &owner_schema._EX_ROLE');
END;
/

-- Set current schema to owner for table creation
ALTER SESSION SET CURRENT_SCHEMA = &owner_schema;
PROMPT ✓ Current schema set to &owner_schema
PROMPT ========================================

-- ==========================================
-- STEP 1: CREATE ALL TABLES (Structure Only)
-- ==========================================
PROMPT
PROMPT Step 1: Creating all tables (structure only)...
PROMPT ========================================

-- 1. REGIONS (Non-partitioned reference table)
CREATE TABLE REGIONS (
    REGION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)
        CONSTRAINT PK_REGIONS PRIMARY KEY,
    REGION_CODE VARCHAR2(10) NOT NULL,
    REGION_NAME VARCHAR2(100) NOT NULL,
    COUNTRY_CODE VARCHAR2(3) NOT NULL,
    IS_ACTIVE CHAR(1) DEFAULT 'Y',
    CREATED_DATE DATE DEFAULT SYSDATE NOT NULL,
    CREATED_BY VARCHAR2(100) DEFAULT USER NOT NULL,
    UPDATED_DATE DATE,
    UPDATED_BY VARCHAR2(100)
) TABLESPACE &tablespace_name;

-- 2. PRODUCTS (Non-partitioned reference table)
CREATE TABLE PRODUCTS (
    PRODUCT_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1000 INCREMENT BY 1)
        CONSTRAINT PK_PRODUCTS PRIMARY KEY,
    PRODUCT_CODE VARCHAR2(20) NOT NULL,
    PRODUCT_NAME VARCHAR2(200) NOT NULL,
    CATEGORY VARCHAR2(50) NOT NULL,
    UNIT_PRICE NUMBER(10,2) NOT NULL,
    COST NUMBER(10,2) NOT NULL,
    MARGIN AS (ROUND((UNIT_PRICE - COST) / COST * 100, 2)) VIRTUAL,
    IS_ACTIVE CHAR(1) DEFAULT 'Y',
    CREATED_DATE DATE DEFAULT SYSDATE NOT NULL,
    CREATED_BY VARCHAR2(100) DEFAULT USER NOT NULL
) TABLESPACE &tablespace_name;

-- 3. SALES_REPS (Non-partitioned reference table)
CREATE TABLE SALES_REPS (
    REP_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 100 INCREMENT BY 1)
        CONSTRAINT PK_SALES_REPS PRIMARY KEY,
    EMPLOYEE_ID VARCHAR2(20) NOT NULL,
    FIRST_NAME VARCHAR2(50) NOT NULL,
    LAST_NAME VARCHAR2(50) NOT NULL,
    EMAIL VARCHAR2(255) NOT NULL,
    PHONE VARCHAR2(20),
    REGION_ID NUMBER NOT NULL,
    HIRE_DATE DATE DEFAULT SYSDATE NOT NULL,
    COMMISSION_RATE NUMBER(5,4) DEFAULT 0.05,
    IS_ACTIVE CHAR(1) DEFAULT 'Y'
) TABLESPACE &tablespace_name;

-- 4. CUSTOMERS (Non-partitioned reference table)
CREATE TABLE CUSTOMERS (
    CUSTOMER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 10000 INCREMENT BY 1)
        CONSTRAINT PK_CUSTOMERS PRIMARY KEY,
    CUSTOMER_CODE VARCHAR2(20) NOT NULL,
    COMPANY_NAME VARCHAR2(200) NOT NULL,
    CONTACT_PERSON VARCHAR2(100),
    EMAIL VARCHAR2(255),
    PHONE VARCHAR2(50),
    ADDRESS_LINE1 VARCHAR2(500),
    ADDRESS_LINE2 VARCHAR2(500),
    CITY VARCHAR2(100),
    STATE VARCHAR2(100),
    POSTAL_CODE VARCHAR2(20),
    REGION_ID NUMBER NOT NULL,
    ASSIGNED_REP_ID NUMBER,
    CUSTOMER_TYPE VARCHAR2(20) DEFAULT 'STANDARD',
    CREDIT_LIMIT NUMBER(12,2) DEFAULT 10000,
    IS_ACTIVE CHAR(1) DEFAULT 'Y',
    REGISTRATION_DATE DATE DEFAULT SYSDATE NOT NULL,
    CREATED_BY VARCHAR2(100) DEFAULT USER NOT NULL
) TABLESPACE &tablespace_name;

-- 5. SALES_HISTORY (Range Partitioned)
CREATE TABLE SALES_HISTORY (
    SALES_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1000 INCREMENT BY 1),
    PRODUCT_ID NUMBER NOT NULL,
    CUSTOMER_ID NUMBER NOT NULL,
    SALES_REP_ID NUMBER NOT NULL,
    SALE_DATE DATE NOT NULL,
    QUANTITY NUMBER NOT NULL,
    UNIT_PRICE NUMBER(10,2) NOT NULL,
    TOTAL_AMOUNT NUMBER(12,2) NOT NULL,
    DISCOUNT_PERCENT NUMBER(5,2) DEFAULT 0,
    NET_AMOUNT AS (TOTAL_AMOUNT * (1 - DISCOUNT_PERCENT/100)) VIRTUAL,
    COMMISSION_AMOUNT AS (TOTAL_AMOUNT * 0.05) VIRTUAL,
    SALE_TYPE VARCHAR2(20) DEFAULT 'REGULAR',
    PAYMENT_METHOD VARCHAR2(20) DEFAULT 'CREDIT',
    ORDER_NUMBER VARCHAR2(50),
    NOTES CLOB,
    ATTACHMENT BLOB,
    CREATED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    CREATED_BY VARCHAR2(100) DEFAULT USER,
    UPDATED_AT TIMESTAMP(6),
    UPDATED_BY VARCHAR2(100),
    CONSTRAINT PK_SALES_HISTORY PRIMARY KEY (SALES_ID, SALE_DATE)
)
PARTITION BY RANGE (SALE_DATE) (
    PARTITION P_2023 VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q1 VALUES LESS THAN (TO_DATE('2024-04-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q2 VALUES LESS THAN (TO_DATE('2024-07-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q3 VALUES LESS THAN (TO_DATE('2024-10-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q4 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD')),
    PARTITION P_FUTURE VALUES LESS THAN (MAXVALUE)
)
TABLESPACE &tablespace_name
ENABLE ROW MOVEMENT;

-- 6. CUSTOMER_REGIONS (List Partitioned)
CREATE TABLE CUSTOMER_REGIONS (
    CUSTOMER_REGION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 2000 INCREMENT BY 1),
    CUSTOMER_ID NUMBER NOT NULL,
    REGION_CODE VARCHAR2(10) NOT NULL,
    COUNTRY_CODE VARCHAR2(3) NOT NULL,
    LOCAL_CONTACT_NAME VARCHAR2(200),
    LOCAL_PHONE VARCHAR2(50),
    LOCAL_EMAIL VARCHAR2(255),
    LOCAL_ADDRESS CLOB,
    TAX_ID VARCHAR2(50),
    CURRENCY_CODE VARCHAR2(3) DEFAULT 'USD',
    REGISTRATION_DATE DATE DEFAULT SYSDATE NOT NULL,
    STATUS VARCHAR2(20) DEFAULT 'ACTIVE',
    LAST_ORDER_DATE DATE,
    CREDIT_RATING VARCHAR2(10) DEFAULT 'GOOD',
    CREATED_BY VARCHAR2(100) DEFAULT USER,
    CONSTRAINT PK_CUSTOMER_REGIONS PRIMARY KEY (CUSTOMER_REGION_ID, REGION_CODE)
)
PARTITION BY LIST (REGION_CODE) (
    PARTITION P_NORTH_AMERICA VALUES ('US', 'CA', 'MX'),
    PARTITION P_EUROPE VALUES ('UK', 'DE', 'FR', 'IT', 'ES', 'NL', 'BE', 'CH'),
    PARTITION P_ASIA VALUES ('JP', 'CN', 'IN', 'KR', 'SG', 'TH', 'MY', 'ID'),
    PARTITION P_OCEANIA VALUES ('AU', 'NZ', 'FJ'),
    PARTITION P_OTHER VALUES (DEFAULT)
)
TABLESPACE &tablespace_name
ENABLE ROW MOVEMENT;

-- 7. USER_SESSIONS (Hash Partitioned)
CREATE TABLE USER_SESSIONS (
    SESSION_ID VARCHAR2(100) NOT NULL,
    USER_ID NUMBER NOT NULL,
    LOGIN_TIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    LOGOUT_TIME TIMESTAMP(6),
    IP_ADDRESS VARCHAR2(45),
    USER_AGENT VARCHAR2(500),
    SESSION_DATA BLOB,
    ACTIVITY_LOG CLOB,
    IS_MOBILE CHAR(1) DEFAULT 'N',
    DEVICE_TYPE VARCHAR2(50),
    CONSTRAINT PK_USER_SESSIONS PRIMARY KEY (SESSION_ID, USER_ID)
)
PARTITION BY HASH (USER_ID) PARTITIONS 8
TABLESPACE &tablespace_name
ENABLE ROW MOVEMENT;

-- 8. AUDIT_LOG (Interval Partitioned)
CREATE TABLE AUDIT_LOG (
    LOG_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 5000 INCREMENT BY 1),
    TABLE_NAME VARCHAR2(128) NOT NULL,
    OPERATION VARCHAR2(10) NOT NULL,
    USER_NAME VARCHAR2(128),
    TIMESTAMP_CREATED TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    OLD_VALUES CLOB,
    NEW_VALUES CLOB,
    SQL_STATEMENT CLOB,
    SESSION_ID VARCHAR2(100),
    OS_USER VARCHAR2(100),
    IP_ADDRESS VARCHAR2(45),
    CONSTRAINT PK_AUDIT_LOG PRIMARY KEY (LOG_ID, TIMESTAMP_CREATED)
)
PARTITION BY RANGE (TIMESTAMP_CREATED)
INTERVAL (INTERVAL '1' MONTH) (
    PARTITION P_INITIAL VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD'))
)
TABLESPACE &tablespace_name
ENABLE ROW MOVEMENT;

-- 9. ORDER_DETAILS (Range-Hash Composite)
CREATE TABLE ORDER_DETAILS (
    ORDER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 10000 INCREMENT BY 1),
    ORDER_DATE DATE NOT NULL,
    CUSTOMER_ID NUMBER NOT NULL,
    PRODUCT_ID NUMBER NOT NULL,
    QUANTITY NUMBER DEFAULT 1,
    UNIT_PRICE NUMBER(10,2) NOT NULL,
    DISCOUNT_PERCENT NUMBER(5,2) DEFAULT 0,
    LINE_TOTAL AS (QUANTITY * UNIT_PRICE * (1 - DISCOUNT_PERCENT/100)) VIRTUAL,
    ORDER_STATUS VARCHAR2(20) DEFAULT 'PENDING',
    SHIPPING_ADDRESS CLOB,
    SPECIAL_INSTRUCTIONS CLOB,
    CREATED_BY VARCHAR2(100),
    CREATED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    UPDATED_AT TIMESTAMP(6),
    CONSTRAINT PK_ORDER_DETAILS PRIMARY KEY (ORDER_ID, ORDER_DATE, CUSTOMER_ID)
)
PARTITION BY RANGE (ORDER_DATE)
SUBPARTITION BY HASH (CUSTOMER_ID) SUBPARTITIONS 4 (
    PARTITION P_2024_Q1 VALUES LESS THAN (TO_DATE('2024-04-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q2 VALUES LESS THAN (TO_DATE('2024-07-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q3 VALUES LESS THAN (TO_DATE('2024-10-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q4 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD')),
    PARTITION P_FUTURE VALUES LESS THAN (MAXVALUE)
)
TABLESPACE &tablespace_name
ENABLE ROW MOVEMENT;

-- 10. TRANSACTION_LOG (Interval-Hash Composite)
CREATE TABLE TRANSACTION_LOG (
    TRANSACTION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 20000 INCREMENT BY 1),
    TRANSACTION_DATE TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    ACCOUNT_ID NUMBER NOT NULL,
    TRANSACTION_TYPE VARCHAR2(50) NOT NULL,
    AMOUNT NUMBER(15,2) NOT NULL,
    CURRENCY VARCHAR2(3) DEFAULT 'USD',
    DESCRIPTION VARCHAR2(500),
    REFERENCE_NUMBER VARCHAR2(100),
    STATUS VARCHAR2(20) DEFAULT 'PENDING',
    PROCESSED_BY VARCHAR2(100),
    AUTHORIZATION_CODE VARCHAR2(50),
    MERCHANT_ID VARCHAR2(50),
    CARD_DETAILS BLOB,
    AUDIT_TRAIL CLOB,
    CREATED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    UPDATED_AT TIMESTAMP(6),
    CONSTRAINT PK_TRANSACTION_LOG PRIMARY KEY (TRANSACTION_ID, TRANSACTION_DATE, ACCOUNT_ID)
)
PARTITION BY RANGE (TRANSACTION_DATE)
INTERVAL (INTERVAL '1' DAY)
SUBPARTITION BY HASH (ACCOUNT_ID) SUBPARTITIONS 8 (
    PARTITION P_INITIAL VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD'))
)
TABLESPACE &tablespace_name
ENABLE ROW MOVEMENT;

PROMPT ✓ All tables created successfully
PROMPT ========================================

-- ==========================================
-- STEP 2: CREATE ALL INDEXES
-- ==========================================
PROMPT
PROMPT Step 2: Creating all indexes...
PROMPT ========================================

-- Reference table indexes (non-partitioned)
-- Note: Skip REGIONS.REGION_CODE as it has unique constraint which creates index automatically
CREATE INDEX IDX_REGIONS_COUNTRY ON REGIONS (COUNTRY_CODE, IS_ACTIVE);
CREATE INDEX IDX_REGIONS_ACTIVE ON REGIONS (IS_ACTIVE, CREATED_DATE);

CREATE INDEX IDX_PRODUCTS_CATEGORY ON PRODUCTS (CATEGORY, IS_ACTIVE);
CREATE INDEX IDX_PRODUCTS_PRICE ON PRODUCTS (UNIT_PRICE, CATEGORY);
CREATE INDEX IDX_PRODUCTS_CODE ON PRODUCTS (UPPER(PRODUCT_CODE));
-- Composite index for product searches
CREATE INDEX IDX_PRODUCTS_COMPOSITE ON PRODUCTS (CATEGORY, UNIT_PRICE, IS_ACTIVE);
-- Function-based index
CREATE INDEX IDX_PRODUCTS_MARGIN ON PRODUCTS ((UNIT_PRICE - COST) / COST);

CREATE INDEX IDX_SALES_REPS_REGION ON SALES_REPS (REGION_ID, IS_ACTIVE);
CREATE INDEX IDX_SALES_REPS_EMAIL ON SALES_REPS (UPPER(EMAIL));
CREATE INDEX IDX_SALES_REPS_HIRE ON SALES_REPS (HIRE_DATE, COMMISSION_RATE);
-- Composite index for rep lookups
CREATE INDEX IDX_SALES_REPS_COMPOSITE ON SALES_REPS (REGION_ID, IS_ACTIVE, COMMISSION_RATE);

CREATE INDEX IDX_CUSTOMERS_REGION ON CUSTOMERS (REGION_ID, CUSTOMER_TYPE);
CREATE INDEX IDX_CUSTOMERS_REP ON CUSTOMERS (ASSIGNED_REP_ID, IS_ACTIVE);
CREATE INDEX IDX_CUSTOMERS_TYPE ON CUSTOMERS (CUSTOMER_TYPE, CREDIT_LIMIT);
-- Composite index for customer searches
CREATE INDEX IDX_CUSTOMERS_COMPOSITE ON CUSTOMERS (REGION_ID, CUSTOMER_TYPE, IS_ACTIVE);
-- Function-based index for case-insensitive search
CREATE INDEX IDX_CUSTOMERS_NAME_UPPER ON CUSTOMERS (UPPER(COMPANY_NAME));

-- Partitioned table indexes (all LOCAL)
-- SALES_HISTORY indexes
CREATE INDEX IDX_SALES_PRODUCT ON SALES_HISTORY (PRODUCT_ID) LOCAL;
CREATE INDEX IDX_SALES_CUSTOMER ON SALES_HISTORY (CUSTOMER_ID) LOCAL;
CREATE INDEX IDX_SALES_REP ON SALES_HISTORY (SALES_REP_ID) LOCAL;
CREATE INDEX IDX_SALES_TYPE ON SALES_HISTORY (SALE_TYPE, PAYMENT_METHOD) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_SALES_ANALYSIS ON SALES_HISTORY (SALE_TYPE, TOTAL_AMOUNT, SALE_DATE) LOCAL;
CREATE INDEX IDX_SALES_CUSTOMER_DATE ON SALES_HISTORY (CUSTOMER_ID, SALE_DATE, TOTAL_AMOUNT) LOCAL;
-- Function-based local index (use the virtual column instead of the expression)
CREATE INDEX IDX_SALES_NET_AMOUNT ON SALES_HISTORY (NET_AMOUNT) LOCAL;

-- CUSTOMER_REGIONS indexes
CREATE INDEX IDX_CUSTREG_CUSTOMER ON CUSTOMER_REGIONS (CUSTOMER_ID) LOCAL;
CREATE INDEX IDX_CUSTREG_STATUS ON CUSTOMER_REGIONS (STATUS, REGISTRATION_DATE) LOCAL;
CREATE INDEX IDX_CUSTREG_CURRENCY ON CUSTOMER_REGIONS (CURRENCY_CODE, CREDIT_RATING) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_CUSTREG_ANALYSIS ON CUSTOMER_REGIONS (STATUS, CREDIT_RATING, CURRENCY_CODE) LOCAL;
CREATE INDEX IDX_CUSTREG_EMAIL_UPPER ON CUSTOMER_REGIONS (UPPER(LOCAL_EMAIL)) LOCAL;

-- USER_SESSIONS indexes
CREATE INDEX IDX_SESSIONS_LOGIN ON USER_SESSIONS (LOGIN_TIME) LOCAL;
CREATE INDEX IDX_SESSIONS_IP ON USER_SESSIONS (IP_ADDRESS) LOCAL;
CREATE INDEX IDX_SESSIONS_DEVICE ON USER_SESSIONS (DEVICE_TYPE, IS_MOBILE) LOCAL;
-- Composite local index for session analysis
CREATE INDEX IDX_SESSIONS_ANALYSIS ON USER_SESSIONS (USER_ID, LOGIN_TIME, DEVICE_TYPE) LOCAL;

-- AUDIT_LOG indexes
CREATE INDEX IDX_AUDIT_TABLE ON AUDIT_LOG (TABLE_NAME, OPERATION) LOCAL;
CREATE INDEX IDX_AUDIT_USER ON AUDIT_LOG (USER_NAME, TIMESTAMP_CREATED) LOCAL;
CREATE INDEX IDX_AUDIT_SESSION ON AUDIT_LOG (SESSION_ID, OPERATION) LOCAL;
-- Composite local index for audit analysis
CREATE INDEX IDX_AUDIT_ANALYSIS ON AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, TIMESTAMP_CREATED) LOCAL;

-- ORDER_DETAILS indexes
CREATE INDEX IDX_ORDER_STATUS ON ORDER_DETAILS (ORDER_STATUS, ORDER_DATE) LOCAL;
CREATE INDEX IDX_ORDER_PRODUCT ON ORDER_DETAILS (PRODUCT_ID) LOCAL;
CREATE INDEX IDX_ORDER_CUSTOMER ON ORDER_DETAILS (CUSTOMER_ID) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_ORDER_ANALYSIS ON ORDER_DETAILS (ORDER_STATUS, CUSTOMER_ID, ORDER_DATE) LOCAL;
CREATE INDEX IDX_ORDER_VALUE ON ORDER_DETAILS (UNIT_PRICE, QUANTITY, DISCOUNT_PERCENT) LOCAL;

-- TRANSACTION_LOG indexes
CREATE INDEX IDX_TRANS_TYPE ON TRANSACTION_LOG (TRANSACTION_TYPE, TRANSACTION_DATE) LOCAL;
CREATE INDEX IDX_TRANS_STATUS ON TRANSACTION_LOG (STATUS, ACCOUNT_ID) LOCAL;
CREATE INDEX IDX_TRANS_CURRENCY ON TRANSACTION_LOG (CURRENCY, AMOUNT) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_TRANS_ANALYSIS ON TRANSACTION_LOG (TRANSACTION_TYPE, STATUS, CURRENCY) LOCAL;
CREATE INDEX IDX_TRANS_ACCOUNT_DATE ON TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_DATE, AMOUNT) LOCAL;

-- Global indexes (use sparingly for cross-partition queries)
CREATE INDEX IDX_SALES_AMOUNT_GLOBAL ON SALES_HISTORY (TOTAL_AMOUNT) GLOBAL
    PARTITION BY RANGE (TOTAL_AMOUNT) (
        PARTITION P_LOW VALUES LESS THAN (1000),
        PARTITION P_MED VALUES LESS THAN (10000),
        PARTITION P_HIGH VALUES LESS THAN (MAXVALUE)
    );

-- IDX_CUSTREG_CUSTOMER_GLOBAL removed - duplicate of existing local index IDX_CUSTREG_CUSTOMER

PROMPT ✓ All indexes created successfully
PROMPT ========================================

-- ==========================================
-- STEP 3: ADD ALL CONSTRAINTS
-- ==========================================
PROMPT
PROMPT Step 3: Adding all constraints...
PROMPT ========================================

-- REGIONS constraints
ALTER TABLE REGIONS ADD CONSTRAINT UK_REGIONS_CODE UNIQUE (REGION_CODE);
ALTER TABLE REGIONS ADD CONSTRAINT CHK_REGIONS_CODE CHECK (REGION_CODE = UPPER(REGION_CODE));
ALTER TABLE REGIONS ADD CONSTRAINT CHK_REGIONS_NAME CHECK (LENGTH(TRIM(REGION_NAME)) >= 2);
ALTER TABLE REGIONS ADD CONSTRAINT CHK_COUNTRY_CODE CHECK (COUNTRY_CODE = UPPER(COUNTRY_CODE));
ALTER TABLE REGIONS ADD CONSTRAINT CHK_REGIONS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N'));

-- PRODUCTS constraints
ALTER TABLE PRODUCTS ADD CONSTRAINT UK_PRODUCTS_CODE UNIQUE (PRODUCT_CODE);
ALTER TABLE PRODUCTS ADD CONSTRAINT CHK_PRODUCTS_CODE CHECK (REGEXP_LIKE(PRODUCT_CODE, '^[A-Z0-9_-]+$'));
ALTER TABLE PRODUCTS ADD CONSTRAINT CHK_PRODUCTS_NAME CHECK (LENGTH(TRIM(PRODUCT_NAME)) >= 3);
ALTER TABLE PRODUCTS ADD CONSTRAINT CHK_PRODUCTS_CATEGORY CHECK (CATEGORY IN ('ELECTRONICS', 'CLOTHING', 'BOOKS', 'HOME', 'SPORTS'));
ALTER TABLE PRODUCTS ADD CONSTRAINT CHK_PRODUCTS_PRICE CHECK (UNIT_PRICE > 0);
ALTER TABLE PRODUCTS ADD CONSTRAINT CHK_PRODUCTS_COST CHECK (COST > 0);
ALTER TABLE PRODUCTS ADD CONSTRAINT CHK_PRODUCTS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N'));
ALTER TABLE PRODUCTS ADD CONSTRAINT CHK_PRODUCTS_MARGIN CHECK (UNIT_PRICE >= COST);

-- SALES_REPS constraints
ALTER TABLE SALES_REPS ADD CONSTRAINT UK_SALES_REPS_EMP UNIQUE (EMPLOYEE_ID);
ALTER TABLE SALES_REPS ADD CONSTRAINT UK_SALES_REPS_EMAIL UNIQUE (EMAIL);
ALTER TABLE SALES_REPS ADD CONSTRAINT CHK_REPS_FNAME CHECK (LENGTH(TRIM(FIRST_NAME)) >= 2);
ALTER TABLE SALES_REPS ADD CONSTRAINT CHK_REPS_LNAME CHECK (LENGTH(TRIM(LAST_NAME)) >= 2);
ALTER TABLE SALES_REPS ADD CONSTRAINT CHK_REPS_EMAIL CHECK (REGEXP_LIKE(EMAIL, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'));
ALTER TABLE SALES_REPS ADD CONSTRAINT CHK_REPS_PHONE CHECK (REGEXP_LIKE(PHONE, '^\+?[0-9\s\-\(\)]+$'));
ALTER TABLE SALES_REPS ADD CONSTRAINT CHK_REPS_COMMISSION CHECK (COMMISSION_RATE BETWEEN 0 AND 1);
ALTER TABLE SALES_REPS ADD CONSTRAINT CHK_REPS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N'));
-- Foreign key
ALTER TABLE SALES_REPS ADD CONSTRAINT FK_REPS_REGION FOREIGN KEY (REGION_ID) REFERENCES REGIONS(REGION_ID);

-- CUSTOMERS constraints
ALTER TABLE CUSTOMERS ADD CONSTRAINT UK_CUSTOMERS_CODE UNIQUE (CUSTOMER_CODE);
ALTER TABLE CUSTOMERS ADD CONSTRAINT CHK_CUSTOMERS_NAME CHECK (LENGTH(TRIM(COMPANY_NAME)) >= 2);
ALTER TABLE CUSTOMERS ADD CONSTRAINT CHK_CUSTOMERS_EMAIL CHECK (EMAIL IS NULL OR REGEXP_LIKE(EMAIL, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'));
ALTER TABLE CUSTOMERS ADD CONSTRAINT CHK_CUSTOMERS_TYPE CHECK (CUSTOMER_TYPE IN ('PREMIUM', 'STANDARD', 'BASIC'));
ALTER TABLE CUSTOMERS ADD CONSTRAINT CHK_CUSTOMERS_CREDIT CHECK (CREDIT_LIMIT >= 0);
ALTER TABLE CUSTOMERS ADD CONSTRAINT CHK_CUSTOMERS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N'));
-- Foreign keys
ALTER TABLE CUSTOMERS ADD CONSTRAINT FK_CUSTOMERS_REGION FOREIGN KEY (REGION_ID) REFERENCES REGIONS(REGION_ID);
ALTER TABLE CUSTOMERS ADD CONSTRAINT FK_CUSTOMERS_REP FOREIGN KEY (ASSIGNED_REP_ID) REFERENCES SALES_REPS(REP_ID);

-- SALES_HISTORY constraints
ALTER TABLE SALES_HISTORY ADD CONSTRAINT CHK_SALES_QUANTITY CHECK (QUANTITY > 0);
ALTER TABLE SALES_HISTORY ADD CONSTRAINT CHK_SALES_UNIT_PRICE CHECK (UNIT_PRICE > 0);
ALTER TABLE SALES_HISTORY ADD CONSTRAINT CHK_SALES_AMOUNT CHECK (TOTAL_AMOUNT > 0);
ALTER TABLE SALES_HISTORY ADD CONSTRAINT CHK_SALES_DISCOUNT CHECK (DISCOUNT_PERCENT BETWEEN 0 AND 50);
ALTER TABLE SALES_HISTORY ADD CONSTRAINT CHK_SALES_TYPE CHECK (SALE_TYPE IN ('REGULAR', 'PROMOTION', 'CLEARANCE', 'BULK'));
ALTER TABLE SALES_HISTORY ADD CONSTRAINT CHK_PAYMENT_METHOD CHECK (PAYMENT_METHOD IN ('CASH', 'CREDIT', 'CHECK', 'WIRE'));
ALTER TABLE SALES_HISTORY ADD CONSTRAINT UK_SALES_ORDER UNIQUE (ORDER_NUMBER);
ALTER TABLE SALES_HISTORY ADD CONSTRAINT CHK_SALES_CALCULATION CHECK (TOTAL_AMOUNT = QUANTITY * UNIT_PRICE);
-- Foreign keys
ALTER TABLE SALES_HISTORY ADD CONSTRAINT FK_SALES_PRODUCT FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS(PRODUCT_ID);
ALTER TABLE SALES_HISTORY ADD CONSTRAINT FK_SALES_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID);
ALTER TABLE SALES_HISTORY ADD CONSTRAINT FK_SALES_REP FOREIGN KEY (SALES_REP_ID) REFERENCES SALES_REPS(REP_ID);

-- CUSTOMER_REGIONS constraints
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT CHK_CUSTREG_CODE CHECK (REGION_CODE = UPPER(REGION_CODE));
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT CHK_CUSTREG_COUNTRY CHECK (COUNTRY_CODE = UPPER(COUNTRY_CODE));
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT CHK_CUSTREG_EMAIL CHECK (LOCAL_EMAIL IS NULL OR
    REGEXP_LIKE(LOCAL_EMAIL, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'));
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT CHK_CUSTREG_CURRENCY CHECK (CURRENCY_CODE IN ('USD', 'EUR', 'GBP', 'JPY', 'CNY', 'INR'));
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT CHK_CUSTREG_STATUS CHECK (STATUS IN ('ACTIVE', 'INACTIVE', 'SUSPENDED', 'PENDING'));
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT CHK_CUSTREG_RATING CHECK (CREDIT_RATING IN ('EXCELLENT', 'GOOD', 'FAIR', 'POOR'));
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT UK_CUSTREG_CUSTOMER UNIQUE (CUSTOMER_ID, REGION_CODE);
-- Table-level constraint for column comparison
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT CHK_CUSTREG_LAST_ORDER CHECK (LAST_ORDER_DATE IS NULL OR LAST_ORDER_DATE >= REGISTRATION_DATE);
-- Foreign key
ALTER TABLE CUSTOMER_REGIONS ADD CONSTRAINT FK_CUSTREG_CUSTOMER FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID);

PROMPT ✓ All constraints added successfully
PROMPT ========================================

-- ==========================================
-- STEP 4: LOAD ALL DATA
-- ==========================================
PROMPT
PROMPT Step 4: Loading all data...
PROMPT ========================================

-- Sample data for REGIONS (specify IDs for foreign key consistency)
INSERT ALL
    INTO REGIONS (REGION_ID, REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES (1, 'US', 'United States', 'USA')
    INTO REGIONS (REGION_ID, REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES (2, 'CA', 'Canada', 'CAN')
    INTO REGIONS (REGION_ID, REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES (3, 'UK', 'United Kingdom', 'GBR')
    INTO REGIONS (REGION_ID, REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES (4, 'DE', 'Germany', 'DEU')
    INTO REGIONS (REGION_ID, REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES (5, 'JP', 'Japan', 'JPN')
    INTO REGIONS (REGION_ID, REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES (6, 'AU', 'Australia', 'AUS')
SELECT * FROM dual;

-- Sample data for PRODUCTS (specify IDs for foreign key consistency)
INSERT ALL
    INTO PRODUCTS (PRODUCT_ID, PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES (1000, 'ELEC-001', 'Wireless Headphones Premium', 'ELECTRONICS', 299.99, 150.00)
    INTO PRODUCTS (PRODUCT_ID, PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES (1001, 'ELEC-002', 'Smartphone Case Deluxe', 'ELECTRONICS', 49.99, 15.00)
    INTO PRODUCTS (PRODUCT_ID, PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES (1002, 'BOOK-001', 'Oracle Database Administrator Guide', 'BOOKS', 89.99, 25.00)
    INTO PRODUCTS (PRODUCT_ID, PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES (1003, 'HOME-001', 'Smart Home Security System', 'HOME', 599.99, 300.00)
    INTO PRODUCTS (PRODUCT_ID, PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES (1004, 'SPRT-001', 'Professional Tennis Racket', 'SPORTS', 199.99, 80.00)
SELECT * FROM dual;

-- Sample data for SALES_REPS (specify IDs for foreign key consistency)
INSERT ALL
    INTO SALES_REPS (REP_ID, EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES (100, 'EMP001', 'John', 'Smith', 'john.smith@company.com', '15550001', 1, 0.06)
    INTO SALES_REPS (REP_ID, EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES (101, 'EMP002', 'Jane', 'Doe', 'jane.doe@company.com', '15550002', 1, 0.05)
    INTO SALES_REPS (REP_ID, EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES (102, 'EMP003', 'Alice', 'Johnson', 'alice.johnson@company.com', '442070000003', 3, 0.055)
    INTO SALES_REPS (REP_ID, EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES (103, 'EMP004', 'Bob', 'Wilson', 'bob.wilson@company.com', '493000000004', 4, 0.05)
    INTO SALES_REPS (REP_ID, EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES (104, 'EMP005', 'Yuki', 'Tanaka', 'yuki.tanaka@company.com', '81300000005', 5, 0.07)
SELECT * FROM dual;

-- Sample data for CUSTOMERS (specify IDs for foreign key consistency)
INSERT ALL
    INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES (10000, 'CUST001', 'Acme Corporation', 'Tom Anderson', 'tom@acme.com', '15551001', 1, 100, 'PREMIUM', 50000)
    INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES (10001, 'CUST002', 'TechStart Inc', 'Sarah Connor', 'sarah@techstart.com', '15551002', 1, 101, 'STANDARD', 25000)
    INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES (10002, 'CUST003', 'British Innovations Ltd', 'James Bond', 'james@british-inn.co.uk', '442070010003', 3, 102, 'PREMIUM', 75000)
    INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES (10003, 'CUST004', 'Deutsche Solutions GmbH', 'Hans Mueller', 'hans@deutsche-sol.de', '493000010004', 4, 103, 'STANDARD', 30000)
    INTO CUSTOMERS (CUSTOMER_ID, CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES (10004, 'CUST005', 'Tokyo Enterprises', 'Akira Sato', 'akira@tokyo-ent.jp', '81300010005', 5, 104, 'PREMIUM', 100000)
SELECT * FROM dual;

-- Sample data for SALES_HISTORY (with foreign key relationships)
INSERT ALL
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1000, 10000, 100, DATE '2023-06-15', 5, 299.99, 1499.95, 10, 'REGULAR', 'CREDIT', 'ORD-2023-001')
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1001, 10001, 101, DATE '2024-02-10', 10, 49.99, 499.90, 5, 'BULK', 'WIRE', 'ORD-2024-001')
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1002, 10002, 102, DATE '2024-05-20', 3, 89.99, 269.97, 0, 'REGULAR', 'CREDIT', 'ORD-2024-002')
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1003, 10003, 103, DATE '2024-08-12', 1, 599.99, 599.99, 0, 'PROMOTION', 'CHECK', 'ORD-2024-003')
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1004, 10004, 104, DATE '2024-11-03', 2, 199.99, 399.98, 15, 'CLEARANCE', 'CASH', 'ORD-2024-004')
SELECT * FROM dual;

-- Sample data for CUSTOMER_REGIONS
INSERT ALL
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10000, 'US', 'USA', 'Tom Anderson', 'contact@acme.com', '+1-555-0123')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10002, 'UK', 'GBR', 'James Bond', 'info@british.co.uk', '+44-20-7000-0001')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10004, 'JP', 'JPN', 'Akira Sato', 'sales@tokyo.jp', '+81-3-0000-0001')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10003, 'DE', 'DEU', 'Hans Mueller', 'kontakt@berlin.de', '+49-30-0000-0001')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10001, 'AU', 'AUS', 'Sarah Connor', 'hello@sydney.com.au', '+61-2-0000-0001')
SELECT * FROM dual;

-- Sample data for USER_SESSIONS (fix LEVEL issue)
-- Insert USER_SESSIONS data using standard approach instead of LEVEL
INSERT INTO USER_SESSIONS (SESSION_ID, USER_ID, IP_ADDRESS, USER_AGENT, IS_MOBILE, DEVICE_TYPE)
VALUES ('sess_000001', 1, '192.168.1.1', 'Mozilla/5.0 Chrome/95.0', 'N', 'Desktop');

INSERT INTO USER_SESSIONS (SESSION_ID, USER_ID, IP_ADDRESS, USER_AGENT, IS_MOBILE, DEVICE_TYPE)
VALUES ('sess_000002', 2, '192.168.1.2', 'Mozilla/5.0 Firefox/94.0', 'N', 'Desktop');

INSERT INTO USER_SESSIONS (SESSION_ID, USER_ID, IP_ADDRESS, USER_AGENT, IS_MOBILE, DEVICE_TYPE)
VALUES ('sess_000003', 3, '192.168.1.3', 'Safari/14.1', 'Y', 'Mobile');

INSERT INTO USER_SESSIONS (SESSION_ID, USER_ID, IP_ADDRESS, USER_AGENT, IS_MOBILE, DEVICE_TYPE)
VALUES ('sess_000004', 4, '192.168.1.4', 'Chrome Mobile/95.0', 'Y', 'Mobile');

INSERT INTO USER_SESSIONS (SESSION_ID, USER_ID, IP_ADDRESS, USER_AGENT, IS_MOBILE, DEVICE_TYPE)
VALUES ('sess_000005', 5, '192.168.1.5', 'Edge/95.0', 'N', 'Desktop');

-- Sample data for AUDIT_LOG (use separate INSERTs to avoid timestamp collision)
INSERT INTO AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, OLD_VALUES, NEW_VALUES, SQL_STATEMENT, TIMESTAMP_CREATED)
VALUES ('PRODUCTS', 'INSERT', 'APP_USER', NULL, '{"product_code":"ELEC-001","status":"active"}', 'INSERT INTO PRODUCTS...',
        TIMESTAMP '2024-01-15 10:00:00.000000');

INSERT INTO AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, OLD_VALUES, NEW_VALUES, SQL_STATEMENT, TIMESTAMP_CREATED)
VALUES ('CUSTOMERS', 'UPDATE', 'APP_USER', '{"status":"active"}', '{"status":"inactive"}', 'UPDATE CUSTOMERS...',
        TIMESTAMP '2024-01-15 10:01:00.000000');

INSERT INTO AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, OLD_VALUES, NEW_VALUES, SQL_STATEMENT, TIMESTAMP_CREATED)
VALUES ('SALES_HISTORY', 'DELETE', 'ADMIN_USER', '{"order_number":"ORD-001"}', NULL, 'DELETE FROM SALES_HISTORY...',
        TIMESTAMP '2024-01-15 10:02:00.000000');

-- Sample data for ORDER_DETAILS
INSERT ALL
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-02-15', 10000, 1000, 5, 29.99, 10, 'SHIPPED')
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-05-22', 10001, 1001, 3, 149.95, 5, 'DELIVERED')
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-08-10', 10002, 1002, 1, 499.00, 0, 'PROCESSING')
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-11-05', 10003, 1003, 2, 75.50, 15, 'PENDING')
SELECT * FROM dual;

-- Sample data for TRANSACTION_LOG
INSERT ALL
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS)
    VALUES (100001, 'PURCHASE', 45.67, 'USD', 'Online Store Purchase', 'COMPLETED')
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS)
    VALUES (100002, 'REFUND', -23.45, 'USD', 'Product Return Refund', 'COMPLETED')
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS)
    VALUES (100003, 'TRANSFER', 1500.00, 'USD', 'Account Transfer', 'PENDING')
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS)
    VALUES (100004, 'DEPOSIT', 2000.00, 'USD', 'Direct Deposit Salary', 'COMPLETED')
SELECT * FROM dual;

PROMPT ✓ All data loaded successfully
PROMPT ========================================

-- ==========================================
-- STEP 5: GATHER STATISTICS
-- ==========================================
PROMPT
PROMPT Step 5: Gathering statistics...
PROMPT ========================================

BEGIN
    DBMS_STATS.GATHER_SCHEMA_STATS('&owner_schema');
    DBMS_OUTPUT.PUT_LINE('✓ Schema statistics gathered for &owner_schema');
END;
/

PROMPT ✓ Statistics gathering complete
PROMPT ========================================

-- ==========================================
-- STEP 6: GRANT PERMISSIONS TO ROLES
-- ==========================================
PROMPT
PROMPT Step 6: Setting up grants and roles...
PROMPT ========================================

-- Grant DML permissions on all tables to DML role
DECLARE
    sql_stmt VARCHAR2(4000);
    obj_count NUMBER := 0;
BEGIN
    FOR tab IN (SELECT table_name FROM all_tables WHERE owner = '&owner_schema') LOOP
        BEGIN
            sql_stmt := 'GRANT SELECT, INSERT, UPDATE, DELETE ON ' || tab.table_name || ' TO &owner_schema._DML_ROLE';
            EXECUTE IMMEDIATE sql_stmt;
            DBMS_OUTPUT.PUT_LINE('✓ Granted DML permissions on ' || tab.table_name);
            obj_count := obj_count + 1;
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Warning: Could not grant DML permissions on ' || tab.table_name || ' - ' || SQLERRM);
        END;
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('✓ Granted DML permissions on ' || obj_count || ' tables');
END;
/

-- Grant EXECUTE permissions on all procedures/functions/packages to EX role
DECLARE
    sql_stmt VARCHAR2(4000);
    obj_count NUMBER := 0;
BEGIN
    FOR obj IN (SELECT object_name, object_type
                FROM all_objects
                WHERE owner = '&owner_schema'
                AND object_type IN ('PROCEDURE', 'FUNCTION', 'PACKAGE', 'TYPE')) LOOP
        BEGIN
            sql_stmt := 'GRANT EXECUTE ON ' || obj.object_name || ' TO &owner_schema._EX_ROLE';
            EXECUTE IMMEDIATE sql_stmt;
            DBMS_OUTPUT.PUT_LINE('✓ Granted EXECUTE permission on ' || obj.object_name);
            obj_count := obj_count + 1;
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Warning: Could not grant EXECUTE permission on ' || obj.object_name || ' - ' || SQLERRM);
        END;
    END LOOP;
    IF obj_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('✓ No procedures/functions/packages found to grant EXECUTE permissions');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ Granted EXECUTE permissions on ' || obj_count || ' objects');
    END IF;
END;
/

-- Grant SELECT permissions on all views to DML role
DECLARE
    sql_stmt VARCHAR2(4000);
    obj_count NUMBER := 0;
BEGIN
    FOR view_rec IN (SELECT view_name FROM all_views WHERE owner = '&owner_schema') LOOP
        BEGIN
            sql_stmt := 'GRANT SELECT ON ' || view_rec.view_name || ' TO &owner_schema._DML_ROLE';
            EXECUTE IMMEDIATE sql_stmt;
            DBMS_OUTPUT.PUT_LINE('✓ Granted SELECT permission on view ' || view_rec.view_name);
            obj_count := obj_count + 1;
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Warning: Could not grant SELECT permission on view ' || view_rec.view_name || ' - ' || SQLERRM);
        END;
    END LOOP;
    IF obj_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('✓ No views found to grant SELECT permissions');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ Granted SELECT permissions on ' || obj_count || ' views');
    END IF;
END;
/

-- Grant SELECT permissions on all sequences to DML role
DECLARE
    sql_stmt VARCHAR2(4000);
    obj_count NUMBER := 0;
BEGIN
    FOR seq IN (SELECT sequence_name FROM all_sequences WHERE sequence_owner = '&owner_schema') LOOP
        BEGIN
            sql_stmt := 'GRANT SELECT ON ' || seq.sequence_name || ' TO &owner_schema._DML_ROLE';
            EXECUTE IMMEDIATE sql_stmt;
            DBMS_OUTPUT.PUT_LINE('✓ Granted SELECT permission on sequence ' || seq.sequence_name);
            obj_count := obj_count + 1;
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Warning: Could not grant SELECT permission on sequence ' || seq.sequence_name || ' - ' || SQLERRM);
        END;
    END LOOP;
    IF obj_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('✓ No sequences found to grant SELECT permissions');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ Granted SELECT permissions on ' || obj_count || ' sequences');
    END IF;
END;
/

-- Grant roles to app schema
DECLARE
BEGIN
    EXECUTE IMMEDIATE 'GRANT &owner_schema._DML_ROLE TO &app_schema';
    DBMS_OUTPUT.PUT_LINE('✓ Granted &owner_schema._DML_ROLE to &app_schema');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Warning: Could not grant &owner_schema._DML_ROLE to &app_schema - ' || SQLERRM);
END;
/

DECLARE
BEGIN
    EXECUTE IMMEDIATE 'GRANT &owner_schema._EX_ROLE TO &app_schema';
    DBMS_OUTPUT.PUT_LINE('✓ Granted &owner_schema._EX_ROLE to &app_schema');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Warning: Could not grant &owner_schema._EX_ROLE to &app_schema - ' || SQLERRM);
END;
/

PROMPT ✓ Grants and roles setup complete
PROMPT ========================================

-- ==========================================
-- VERIFICATION QUERIES
-- ==========================================

SELECT 'Table Counts:' as info FROM dual;

SELECT table_name,
       partitioned,
       num_rows
FROM all_tables
WHERE owner = '&owner_schema'
AND table_name IN ('SALES_HISTORY', 'CUSTOMER_REGIONS', 'USER_SESSIONS',
                   'AUDIT_LOG', 'ORDER_DETAILS', 'TRANSACTION_LOG',
                   'REGIONS', 'PRODUCTS', 'SALES_REPS', 'CUSTOMERS')
ORDER BY table_name;

SELECT 'Partition Information:' as info FROM dual;

SELECT table_name,
       partitioning_type,
       subpartitioning_type,
       partition_count,
       def_subpartition_count,
       interval
FROM all_part_tables
WHERE owner = '&owner_schema'
ORDER BY table_name;

SELECT 'Identity Column Information:' as info FROM dual;

SELECT table_name,
       column_name,
       generation_type,
       sequence_name
FROM all_tab_identity_cols
WHERE owner = '&owner_schema'
ORDER BY table_name, column_name;

COMMIT;

-- ==========================================
-- FINAL SUMMARY AND CONNECTION INFO
-- ==========================================

PROMPT ====================================
PROMPT Oracle Comprehensive Test Environment
PROMPT Setup Complete!
PROMPT ====================================
PROMPT
PROMPT Schemas Created:
PROMPT - Owner Schema: &owner_schema (password: &owner_password)
PROMPT - App Schema:   &app_schema (password: &app_password)
PROMPT
PROMPT Roles Created:
PROMPT - &owner_schema._DML_ROLE (granted to &app_schema)
PROMPT - &owner_schema._EX_ROLE (granted to &app_schema)
PROMPT
PROMPT Tables Created:
PROMPT - REGIONS (Non-partitioned reference)
PROMPT - PRODUCTS (Non-partitioned reference)
PROMPT - SALES_REPS (Non-partitioned reference)
PROMPT - CUSTOMERS (Non-partitioned reference)
PROMPT - SALES_HISTORY (Range Partitioned)
PROMPT - CUSTOMER_REGIONS (List Partitioned)
PROMPT - USER_SESSIONS (Hash Partitioned)
PROMPT - AUDIT_LOG (Interval Partitioned)
PROMPT - ORDER_DETAILS (Range-Hash Composite)
PROMPT - TRANSACTION_LOG (Interval-Hash Composite)
PROMPT
PROMPT Features Included:
PROMPT - Identity columns with sequences
PROMPT - Complex constraints (PK, FK, UK, CK)
PROMPT - Comprehensive indexes (local, global, composite, function-based)
PROMPT - All Oracle partitioning types
PROMPT - CLOB and BLOB columns
PROMPT - Virtual columns
PROMPT - Referential integrity chains
PROMPT
PROMPT Connection Examples:
PROMPT - Owner: sqlplus &owner_schema/&owner_password@your_database
PROMPT - App:   sqlplus &app_schema/&app_password@your_database
PROMPT
PROMPT ====================================
PROMPT Ready for Oracle Table Migration Testing!
PROMPT Use this for discovery: --schema &owner_schema
PROMPT ====================================

-- Enable DBMS_OUTPUT for future sessions
SET SERVEROUTPUT ON