{#
==================================================================
Template: Initial Data Load (Jinja2)
==================================================================
Purpose: Load data from original table to new partitioned table
         with progress monitoring and validation

Context Variables:
  owner                    - Table owner/schema
  table_name              - Original table name
  new_table_name          - New table name
  column_list             - Comma-separated column list
  target_configuration    - Target config dict
    - partition_column    - Partition key for ordering
    - parallel_degree     - Parallel degree for load
  current_state          - Current table state
    - row_count          - Source row count estimate
    - size_gb            - Table size for time estimation
==================================================================
#}
-- ==================================================================
-- DATA LOAD: {{ owner }}.{{ table_name }} -> {{ owner }}.{{ new_table_name }}
-- ==================================================================
-- Generated: {{ generation_date }}
-- Estimated rows: {{ current_state.row_count | format_row_count }}
-- Estimated size: {{ current_state.size_gb | format_size_gb }}
-- Estimated time: {{ current_state.size_gb | estimate_time('load') }}
-- Parallel degree: {{ target_configuration.parallel_degree }}
-- ==================================================================

SET ECHO ON
SET SERVEROUTPUT ON
SET TIMING ON
SET FEEDBACK ON
SET VERIFY OFF

PROMPT ================================================================
PROMPT Step 20: Initial Data Load
PROMPT ================================================================
PROMPT Source: {{ owner }}.{{ table_name }}
PROMPT Target: {{ owner }}.{{ new_table_name }}
PROMPT Method: Parallel INSERT /*+ APPEND */
PROMPT Parallel Degree: {{ target_configuration.parallel_degree }}
PROMPT Estimated Time: {{ current_state.size_gb | estimate_time('load') }}
PROMPT ================================================================

-- Variables for timing and counts
VARIABLE v_start_time VARCHAR2(30)
VARIABLE v_end_time VARCHAR2(30)
VARIABLE v_source_count NUMBER
VARIABLE v_target_count NUMBER
VARIABLE v_batch_size NUMBER

-- Record start time
BEGIN
    SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') INTO :v_start_time FROM dual;
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Data load started at: ' || :v_start_time);
    DBMS_OUTPUT.PUT_LINE('');
END;
/

-- Get source row count
PROMPT Counting source rows...

BEGIN
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM {{ owner }}.{{ table_name }}'
    INTO :v_source_count;
    
    DBMS_OUTPUT.PUT_LINE('Source table row count: ' || TO_CHAR(:v_source_count, '999,999,999,999'));
    DBMS_OUTPUT.PUT_LINE('');
    
    {%- if current_state.row_count > 0 %}
    IF :v_source_count != {{ current_state.row_count }} THEN
        DBMS_OUTPUT.PUT_LINE('NOTE: Row count differs from discovery ({{ current_state.row_count | format_row_count }})');
        DBMS_OUTPUT.PUT_LINE('      This is normal if data has changed since discovery');
    END IF;
    {%- endif %}
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR counting source rows: ' || SQLERRM);
        RAISE;
END;
/

-- Verify target table is empty
PROMPT Verifying target table is empty...

DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count FROM {{ owner }}.{{ new_table_name }};
    
    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('WARNING: Target table has ' || v_count || ' rows!');
        DBMS_OUTPUT.PUT_LINE('         Consider truncating before load');
        RAISE_APPLICATION_ERROR(-20001, 'Target table is not empty');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ Target table is empty - ready for load');
    END IF;
END;
/

-- Disable constraints on target (performance optimization)
PROMPT
PROMPT Disabling constraints on target table...

DECLARE
    v_constraint_count NUMBER := 0;
BEGIN
    FOR c IN (
        SELECT constraint_name, constraint_type
        FROM all_constraints
        WHERE owner = '{{ owner }}'
          AND table_name = '{{ new_table_name }}'
          AND constraint_type IN ('U', 'P', 'R', 'C')
          AND status = 'ENABLED'
        ORDER BY 
            CASE constraint_type
                WHEN 'R' THEN 1  -- Foreign keys first
                WHEN 'C' THEN 2  -- Check constraints
                WHEN 'U' THEN 3  -- Unique
                WHEN 'P' THEN 4  -- Primary key last
            END
    ) LOOP
        BEGIN
            EXECUTE IMMEDIATE 'ALTER TABLE {{ owner }}.{{ new_table_name }} DISABLE CONSTRAINT ' || c.constraint_name;
            v_constraint_count := v_constraint_count + 1;
            DBMS_OUTPUT.PUT_LINE('  Disabled ' || 
                CASE c.constraint_type
                    WHEN 'P' THEN 'PRIMARY KEY'
                    WHEN 'U' THEN 'UNIQUE'
                    WHEN 'R' THEN 'FOREIGN KEY'
                    WHEN 'C' THEN 'CHECK'
                END || ': ' || c.constraint_name);
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('  WARNING: Could not disable ' || c.constraint_name || ': ' || SQLERRM);
        END;
    END LOOP;
    
    IF v_constraint_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('  No constraints to disable');
    ELSE
        DBMS_OUTPUT.PUT_LINE('✓ Disabled ' || v_constraint_count || ' constraint(s)');
    END IF;
END;
/

-- Enable parallel DML
ALTER SESSION ENABLE PARALLEL DML;
ALTER SESSION SET PARALLEL_DEGREE_POLICY = MANUAL;

PROMPT
PROMPT ================================================================
PROMPT Starting Data Load...
PROMPT ================================================================
PROMPT This may take {{ current_state.size_gb | estimate_time('load') }} depending on system load
PROMPT Progress will be shown after completion
PROMPT ================================================================

-- Main data load with append hint
INSERT /*+ APPEND PARALLEL({{ target_configuration.parallel_degree }}) NOLOGGING */ 
INTO {{ owner }}.{{ new_table_name }}
(
    {{ column_list }}
)
SELECT {{ target_configuration.parallel_degree | parallel_hint }}
    {{ column_list }}
FROM 
    {{ owner }}.{{ table_name }}
{%- if target_configuration.partition_column %}
ORDER BY 
    {{ target_configuration.partition_column }}  -- Order by partition key for efficient loading
{%- endif %};

-- Record end time and commit
BEGIN
    SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') INTO :v_end_time FROM dual;
END;
/

COMMIT;

PROMPT
PROMPT ✓ Data load completed and committed


-- Post-data load validation and statistics
@validation/post_data_load_checks.sql {{ owner }} {{ new_table_name }} {{ table_name }} {{ current_state.row_count }} {{ target_configuration.parallel_degree }}

{%- if target_configuration.partition_type in ['INTERVAL', 'RANGE'] %}


-- Partition distribution summary (generic)
@validation/partition_distribution_summary.sql {{ owner }} {{ new_table_name }} {{ target_configuration.subpartition_type }}

{%- endif %}

-- Re-enable constraints
PROMPT
PROMPT ================================================================
PROMPT Re-enabling constraints...
PROMPT ================================================================

DECLARE
    v_constraint_count NUMBER := 0;
    v_failed_count NUMBER := 0;
BEGIN
    FOR c IN (
        SELECT constraint_name, constraint_type
        FROM all_constraints
        WHERE owner = '{{ owner }}'
          AND table_name = '{{ new_table_name }}'
          AND constraint_type IN ('U', 'P', 'R', 'C')
          AND status = 'DISABLED'
        ORDER BY 
            CASE constraint_type
                WHEN 'P' THEN 1  -- Primary key first
                WHEN 'U' THEN 2  -- Unique
                WHEN 'C' THEN 3  -- Check
                WHEN 'R' THEN 4  -- Foreign keys last
            END
    ) LOOP
        BEGIN
            EXECUTE IMMEDIATE 'ALTER TABLE {{ owner }}.{{ new_table_name }} ENABLE NOVALIDATE CONSTRAINT ' || c.constraint_name;
            v_constraint_count := v_constraint_count + 1;
            DBMS_OUTPUT.PUT_LINE('  ✓ Enabled ' || c.constraint_name);
        EXCEPTION
            WHEN OTHERS THEN
                v_failed_count := v_failed_count + 1;
                DBMS_OUTPUT.PUT_LINE('  ✗ Failed to enable ' || c.constraint_name || ': ' || SQLERRM);
        END;
    END LOOP;
    
    IF v_constraint_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('✓ Re-enabled ' || v_constraint_count || ' constraint(s)');
        IF v_failed_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('✗ Failed to enable ' || v_failed_count || ' constraint(s)');
            DBMS_OUTPUT.PUT_LINE('  Manual intervention may be required');
        END IF;
    END IF;
END;
/

-- Final summary
PROMPT
PROMPT ================================================================
PROMPT Step 20 Complete: Data Load SUCCESSFUL
PROMPT ================================================================
PROMPT Status: SUCCESS ✓
PROMPT Source Rows: {{ ':v_source_count' }} (use PRINT v_source_count to see value)
PROMPT Target Rows: {{ ':v_target_count' }} (use PRINT v_target_count to see value)
PROMPT Start Time: {{ ':v_start_time' }}
PROMPT End Time: {{ ':v_end_time' }}
PROMPT
PROMPT Next Steps:
PROMPT   1. Run 30_create_indexes.sql to rebuild indexes
PROMPT   2. Consider running 03_validation/data_comparison.sql
PROMPT   3. Monitor partition growth
PROMPT ================================================================
