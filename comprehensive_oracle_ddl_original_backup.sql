-- Oracle Comprehensive Test DDL with Constraints & Referential Integrity
-- =====================================================================
-- Self-contained script to create complete Oracle test environment
-- Creates schemas, tables, indexes, constraints, data, grants, and roles
-- 
-- Features: Non-partitioned, RANGE, LIST, HASH, INTERVAL, Composite partitioning
-- Includes: Identity columns, LOBs, complex indexes, constraints, foreign keys, 
--          check constraints, composite indexes, referential integrity
-- 
-- Usage: Open in SQL Developer or Toad and run as script - no parameters needed
-- =====================================================================

-- ==========================================
-- SCRIPT SETTINGS
-- ==========================================
SET ECHO OFF
SET FEEDBACK ON
SET SERVEROUTPUT ON SIZE 1000000
SET VERIFY OFF
SET TIMING ON
WHENEVER SQLERROR CONTINUE

-- ==========================================
-- CONFIGURATION VARIABLES (HARDCODED)
-- ==========================================
DEFINE owner_schema = APP_DATA_OWNER
DEFINE app_schema = APP_DATA_USER
DEFINE owner_password = OraclePass123
DEFINE app_password = AppPass123
DEFINE tablespace_name = USERS

PROMPT Script Configuration:
PROMPT - Owner Schema: &owner_schema
PROMPT - App Schema: &app_schema  
PROMPT - Tablespace: &tablespace_name
PROMPT

PROMPT ========================================
PROMPT Oracle Comprehensive Test Environment
PROMPT Creating schemas, roles, tables, and data
PROMPT ========================================

-- ==========================================
-- SCHEMA AND ROLE CREATION
-- ==========================================

-- Drop existing users if they exist (ignore errors)
DECLARE
    user_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO user_exists FROM dba_users WHERE username = '&owner_schema';
    IF user_exists > 0 THEN
        EXECUTE IMMEDIATE 'DROP USER &owner_schema CASCADE';
        DBMS_OUTPUT.PUT_LINE('✓ Dropped existing user &owner_schema');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &owner_schema user did not exist');
END;
/

DECLARE
    user_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO user_exists FROM dba_users WHERE username = '&app_schema';
    IF user_exists > 0 THEN
        EXECUTE IMMEDIATE 'DROP USER &app_schema CASCADE';
        DBMS_OUTPUT.PUT_LINE('✓ Dropped existing user &app_schema');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &app_schema user did not exist');
END;
/

-- Drop existing roles if they exist (ignore errors)
DECLARE
    role_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO role_exists FROM dba_roles WHERE role = '&owner_schema._DML_ROLE';
    IF role_exists > 0 THEN
        EXECUTE IMMEDIATE 'DROP ROLE &owner_schema._DML_ROLE';
        DBMS_OUTPUT.PUT_LINE('✓ Dropped existing role &owner_schema._DML_ROLE');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &owner_schema._DML_ROLE did not exist');
END;
/

DECLARE
    role_exists NUMBER;
BEGIN
    SELECT COUNT(*) INTO role_exists FROM dba_roles WHERE role = '&owner_schema._EX_ROLE';
    IF role_exists > 0 THEN
        EXECUTE IMMEDIATE 'DROP ROLE &owner_schema._EX_ROLE';
        DBMS_OUTPUT.PUT_LINE('✓ Dropped existing role &owner_schema._EX_ROLE');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Note: &owner_schema._EX_ROLE did not exist');
END;
/

-- Create owner schema
CREATE USER &owner_schema IDENTIFIED BY "&owner_password"
  DEFAULT TABLESPACE &tablespace_name
  TEMPORARY TABLESPACE TEMP
  QUOTA UNLIMITED ON &tablespace_name;

GRANT CONNECT, RESOURCE TO &owner_schema;
GRANT CREATE VIEW TO &owner_schema;
GRANT CREATE PROCEDURE TO &owner_schema;
GRANT CREATE SEQUENCE TO &owner_schema;
GRANT CREATE TRIGGER TO &owner_schema;
GRANT CREATE SYNONYM TO &owner_schema;

-- Create app schema
CREATE USER &app_schema IDENTIFIED BY "&app_password"
  DEFAULT TABLESPACE &tablespace_name
  TEMPORARY TABLESPACE TEMP
  QUOTA 0 ON &tablespace_name;

GRANT CONNECT TO &app_schema;
GRANT CREATE SYNONYM TO &app_schema;

PROMPT ✓ Created &owner_schema (owner schema)
PROMPT ✓ Created &app_schema (app schema)

-- Create DML role
DECLARE
BEGIN
    EXECUTE IMMEDIATE 'CREATE ROLE &owner_schema._DML_ROLE';
    DBMS_OUTPUT.PUT_LINE('✓ Created role: &owner_schema._DML_ROLE');
END;
/

-- Create EXECUTE role  
DECLARE
BEGIN
    EXECUTE IMMEDIATE 'CREATE ROLE &owner_schema._EX_ROLE';
    DBMS_OUTPUT.PUT_LINE('✓ Created role: &owner_schema._EX_ROLE');
END;
/

-- Set current schema to owner for table creation
ALTER SESSION SET CURRENT_SCHEMA = &owner_schema;
PROMPT ✓ Current schema set to &owner_schema
PROMPT ========================================

-- ==========================================
-- 1. REFERENCE/LOOKUP TABLES (Non-partitioned with constraints)
-- ==========================================

-- Regions lookup table
CREATE TABLE REGIONS (
    REGION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) 
        CONSTRAINT PK_REGIONS PRIMARY KEY,
    REGION_CODE VARCHAR2(10) NOT NULL 
        CONSTRAINT UK_REGIONS_CODE UNIQUE
        CONSTRAINT CHK_REGIONS_CODE CHECK (REGION_CODE = UPPER(REGION_CODE)),
    REGION_NAME VARCHAR2(100) NOT NULL
        CONSTRAINT CHK_REGIONS_NAME CHECK (LENGTH(TRIM(REGION_NAME)) >= 2),
    COUNTRY_CODE VARCHAR2(3) NOT NULL
        CONSTRAINT CHK_COUNTRY_CODE CHECK (COUNTRY_CODE = UPPER(COUNTRY_CODE)),
    IS_ACTIVE CHAR(1) DEFAULT 'Y'
        CONSTRAINT CHK_REGIONS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N')),
    CREATED_DATE DATE DEFAULT SYSDATE NOT NULL,
    CREATED_BY VARCHAR2(100) DEFAULT USER NOT NULL,
    UPDATED_DATE DATE,
    UPDATED_BY VARCHAR2(100)
) TABLESPACE &tablespace_name;

-- Products lookup table  
CREATE TABLE PRODUCTS (
    PRODUCT_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1000 INCREMENT BY 1)
        CONSTRAINT PK_PRODUCTS PRIMARY KEY,
    PRODUCT_CODE VARCHAR2(20) NOT NULL
        CONSTRAINT UK_PRODUCTS_CODE UNIQUE
        CONSTRAINT CHK_PRODUCTS_CODE CHECK (REGEXP_LIKE(PRODUCT_CODE, '^[A-Z0-9_-]+$')),
    PRODUCT_NAME VARCHAR2(200) NOT NULL
        CONSTRAINT CHK_PRODUCTS_NAME CHECK (LENGTH(TRIM(PRODUCT_NAME)) >= 3),
    CATEGORY VARCHAR2(50) NOT NULL
        CONSTRAINT CHK_PRODUCTS_CATEGORY CHECK (CATEGORY IN ('ELECTRONICS', 'CLOTHING', 'BOOKS', 'HOME', 'SPORTS')),
    UNIT_PRICE NUMBER(10,2) NOT NULL
        CONSTRAINT CHK_PRODUCTS_PRICE CHECK (UNIT_PRICE > 0),
    COST NUMBER(10,2) NOT NULL
        CONSTRAINT CHK_PRODUCTS_COST CHECK (COST > 0),
    MARGIN AS (ROUND((UNIT_PRICE - COST) / COST * 100, 2)) VIRTUAL,
    IS_ACTIVE CHAR(1) DEFAULT 'Y'
        CONSTRAINT CHK_PRODUCTS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N')),
    CREATED_DATE DATE DEFAULT SYSDATE NOT NULL,
    CREATED_BY VARCHAR2(100) DEFAULT USER NOT NULL,
    CONSTRAINT CHK_PRODUCTS_MARGIN CHECK (UNIT_PRICE >= COST)
) TABLESPACE &tablespace_name;

-- Sales Representatives
CREATE TABLE SALES_REPS (
    REP_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 100 INCREMENT BY 1)
        CONSTRAINT PK_SALES_REPS PRIMARY KEY,
    EMPLOYEE_ID VARCHAR2(20) NOT NULL
        CONSTRAINT UK_SALES_REPS_EMP UNIQUE,
    FIRST_NAME VARCHAR2(50) NOT NULL
        CONSTRAINT CHK_REPS_FNAME CHECK (LENGTH(TRIM(FIRST_NAME)) >= 2),
    LAST_NAME VARCHAR2(50) NOT NULL
        CONSTRAINT CHK_REPS_LNAME CHECK (LENGTH(TRIM(LAST_NAME)) >= 2),
    EMAIL VARCHAR2(255) NOT NULL
        CONSTRAINT UK_SALES_REPS_EMAIL UNIQUE
        CONSTRAINT CHK_REPS_EMAIL CHECK (REGEXP_LIKE(EMAIL, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')),
    PHONE VARCHAR2(20)
        CONSTRAINT CHK_REPS_PHONE CHECK (REGEXP_LIKE(PHONE, '^\+?[0-9\s\-\(\)]+$')),
    REGION_ID NUMBER NOT NULL
        CONSTRAINT FK_REPS_REGION REFERENCES REGIONS(REGION_ID),
    HIRE_DATE DATE DEFAULT SYSDATE NOT NULL,
    COMMISSION_RATE NUMBER(5,4) DEFAULT 0.05
        CONSTRAINT CHK_REPS_COMMISSION CHECK (COMMISSION_RATE BETWEEN 0 AND 1),
    IS_ACTIVE CHAR(1) DEFAULT 'Y'
        CONSTRAINT CHK_REPS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N'))
) TABLESPACE &tablespace_name;

-- Customers master table
CREATE TABLE CUSTOMERS (
    CUSTOMER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 10000 INCREMENT BY 1)
        CONSTRAINT PK_CUSTOMERS PRIMARY KEY,
    CUSTOMER_CODE VARCHAR2(20) NOT NULL
        CONSTRAINT UK_CUSTOMERS_CODE UNIQUE,
    COMPANY_NAME VARCHAR2(200) NOT NULL
        CONSTRAINT CHK_CUSTOMERS_NAME CHECK (LENGTH(TRIM(COMPANY_NAME)) >= 2),
    CONTACT_PERSON VARCHAR2(100),
    EMAIL VARCHAR2(255)
        CONSTRAINT CHK_CUSTOMERS_EMAIL CHECK (EMAIL IS NULL OR REGEXP_LIKE(EMAIL, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')),
    PHONE VARCHAR2(50),
    ADDRESS_LINE1 VARCHAR2(500),
    ADDRESS_LINE2 VARCHAR2(500),
    CITY VARCHAR2(100),
    STATE VARCHAR2(100),
    POSTAL_CODE VARCHAR2(20),
    REGION_ID NUMBER NOT NULL
        CONSTRAINT FK_CUSTOMERS_REGION REFERENCES REGIONS(REGION_ID),
    ASSIGNED_REP_ID NUMBER
        CONSTRAINT FK_CUSTOMERS_REP REFERENCES SALES_REPS(REP_ID),
    CUSTOMER_TYPE VARCHAR2(20) DEFAULT 'STANDARD'
        CONSTRAINT CHK_CUSTOMERS_TYPE CHECK (CUSTOMER_TYPE IN ('PREMIUM', 'STANDARD', 'BASIC')),
    CREDIT_LIMIT NUMBER(12,2) DEFAULT 10000
        CONSTRAINT CHK_CUSTOMERS_CREDIT CHECK (CREDIT_LIMIT >= 0),
    IS_ACTIVE CHAR(1) DEFAULT 'Y'
        CONSTRAINT CHK_CUSTOMERS_ACTIVE CHECK (IS_ACTIVE IN ('Y', 'N')),
    REGISTRATION_DATE DATE DEFAULT SYSDATE NOT NULL,
    CREATED_BY VARCHAR2(100) DEFAULT USER NOT NULL
) TABLESPACE &tablespace_name;

-- ==========================================
-- 2. RANGE PARTITIONED TABLE (With comprehensive constraints)
-- ==========================================
CREATE TABLE SALES_HISTORY (
    SALES_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1000 INCREMENT BY 1),
    PRODUCT_ID NUMBER NOT NULL
        CONSTRAINT FK_SALES_PRODUCT REFERENCES PRODUCTS(PRODUCT_ID),
    CUSTOMER_ID NUMBER NOT NULL
        CONSTRAINT FK_SALES_CUSTOMER REFERENCES CUSTOMERS(CUSTOMER_ID),
    SALES_REP_ID NUMBER NOT NULL
        CONSTRAINT FK_SALES_REP REFERENCES SALES_REPS(REP_ID),
    SALE_DATE DATE NOT NULL,
    QUANTITY NUMBER NOT NULL
        CONSTRAINT CHK_SALES_QUANTITY CHECK (QUANTITY > 0),
    UNIT_PRICE NUMBER(10,2) NOT NULL
        CONSTRAINT CHK_SALES_UNIT_PRICE CHECK (UNIT_PRICE > 0),
    TOTAL_AMOUNT NUMBER(12,2) NOT NULL
        CONSTRAINT CHK_SALES_AMOUNT CHECK (TOTAL_AMOUNT > 0),
    DISCOUNT_PERCENT NUMBER(5,2) DEFAULT 0
        CONSTRAINT CHK_SALES_DISCOUNT CHECK (DISCOUNT_PERCENT BETWEEN 0 AND 50),
    NET_AMOUNT AS (TOTAL_AMOUNT * (1 - DISCOUNT_PERCENT/100)) VIRTUAL,
    COMMISSION_AMOUNT AS (TOTAL_AMOUNT * 0.05) VIRTUAL,
    SALE_TYPE VARCHAR2(20) DEFAULT 'REGULAR'
        CONSTRAINT CHK_SALES_TYPE CHECK (SALE_TYPE IN ('REGULAR', 'PROMOTION', 'CLEARANCE', 'BULK')),
    PAYMENT_METHOD VARCHAR2(20) DEFAULT 'CREDIT'
        CONSTRAINT CHK_PAYMENT_METHOD CHECK (PAYMENT_METHOD IN ('CASH', 'CREDIT', 'CHECK', 'WIRE')),
    ORDER_NUMBER VARCHAR2(50)
        CONSTRAINT UK_SALES_ORDER UNIQUE,
    NOTES CLOB,
    ATTACHMENT BLOB,
    CREATED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    CREATED_BY VARCHAR2(100) DEFAULT USER,
    UPDATED_AT TIMESTAMP(6),
    UPDATED_BY VARCHAR2(100),
    CONSTRAINT PK_SALES_HISTORY PRIMARY KEY (SALES_ID, SALE_DATE),
    CONSTRAINT CHK_SALES_CALCULATION CHECK (TOTAL_AMOUNT = QUANTITY * UNIT_PRICE)
)
PARTITION BY RANGE (SALE_DATE) (
    PARTITION P_2023 VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q1 VALUES LESS THAN (TO_DATE('2024-04-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q2 VALUES LESS THAN (TO_DATE('2024-07-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q3 VALUES LESS THAN (TO_DATE('2024-10-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q4 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD')),
    PARTITION P_FUTURE VALUES LESS THAN (MAXVALUE)
)
TABLESPACE USERS
ENABLE ROW MOVEMENT;

-- ==========================================
-- 3. LIST PARTITIONED TABLE (Regional customer data)
-- ==========================================
CREATE TABLE CUSTOMER_REGIONS (
    CUSTOMER_REGION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 2000 INCREMENT BY 1),
    CUSTOMER_ID NUMBER NOT NULL
        CONSTRAINT FK_CUSTREG_CUSTOMER REFERENCES CUSTOMERS(CUSTOMER_ID),
    REGION_CODE VARCHAR2(10) NOT NULL
        CONSTRAINT CHK_CUSTREG_CODE CHECK (REGION_CODE = UPPER(REGION_CODE)),
    COUNTRY_CODE VARCHAR2(3) NOT NULL
        CONSTRAINT CHK_CUSTREG_COUNTRY CHECK (COUNTRY_CODE = UPPER(COUNTRY_CODE)),
    LOCAL_CONTACT_NAME VARCHAR2(200),
    LOCAL_PHONE VARCHAR2(50),
    LOCAL_EMAIL VARCHAR2(255)
        CONSTRAINT CHK_CUSTREG_EMAIL CHECK (LOCAL_EMAIL IS NULL OR 
            REGEXP_LIKE(LOCAL_EMAIL, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')),
    LOCAL_ADDRESS CLOB,
    TAX_ID VARCHAR2(50),
    CURRENCY_CODE VARCHAR2(3) DEFAULT 'USD'
        CONSTRAINT CHK_CUSTREG_CURRENCY CHECK (CURRENCY_CODE IN ('USD', 'EUR', 'GBP', 'JPY', 'CNY', 'INR')),
    REGISTRATION_DATE DATE DEFAULT SYSDATE NOT NULL,
    STATUS VARCHAR2(20) DEFAULT 'ACTIVE'
        CONSTRAINT CHK_CUSTREG_STATUS CHECK (STATUS IN ('ACTIVE', 'INACTIVE', 'SUSPENDED', 'PENDING')),
    LAST_ORDER_DATE DATE,
    CREDIT_RATING VARCHAR2(10) DEFAULT 'GOOD'
        CONSTRAINT CHK_CUSTREG_RATING CHECK (CREDIT_RATING IN ('EXCELLENT', 'GOOD', 'FAIR', 'POOR')),
    CREATED_BY VARCHAR2(100) DEFAULT USER,
    CONSTRAINT PK_CUSTOMER_REGIONS PRIMARY KEY (CUSTOMER_REGION_ID, REGION_CODE),
    CONSTRAINT UK_CUSTREG_CUSTOMER UNIQUE (CUSTOMER_ID, REGION_CODE),
    CONSTRAINT CHK_CUSTREG_LAST_ORDER CHECK (LAST_ORDER_DATE IS NULL OR LAST_ORDER_DATE >= REGISTRATION_DATE)
)
PARTITION BY LIST (REGION_CODE) (
    PARTITION P_NORTH_AMERICA VALUES ('US', 'CA', 'MX'),
    PARTITION P_EUROPE VALUES ('UK', 'DE', 'FR', 'IT', 'ES', 'NL', 'BE', 'CH'),
    PARTITION P_ASIA VALUES ('JP', 'CN', 'IN', 'KR', 'SG', 'TH', 'MY', 'ID'),
    PARTITION P_OCEANIA VALUES ('AU', 'NZ', 'FJ'),
    PARTITION P_OTHER VALUES (DEFAULT)
)
TABLESPACE USERS
ENABLE ROW MOVEMENT;

-- ==========================================
-- 4. HASH PARTITIONED TABLE
-- ==========================================
CREATE TABLE USER_SESSIONS (
    SESSION_ID VARCHAR2(100) NOT NULL,
    USER_ID NUMBER NOT NULL,
    LOGIN_TIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    LOGOUT_TIME TIMESTAMP(6),
    IP_ADDRESS VARCHAR2(45),
    USER_AGENT VARCHAR2(500),
    SESSION_DATA BLOB,
    ACTIVITY_LOG CLOB,
    IS_MOBILE CHAR(1) DEFAULT 'N',
    DEVICE_TYPE VARCHAR2(50),
    CONSTRAINT PK_USER_SESSIONS PRIMARY KEY (SESSION_ID, USER_ID)
)
PARTITION BY HASH (USER_ID) PARTITIONS 8
TABLESPACE USERS
ENABLE ROW MOVEMENT;

-- ==========================================
-- 5. INTERVAL PARTITIONED TABLE
-- ==========================================
CREATE TABLE AUDIT_LOG (
    LOG_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 5000 INCREMENT BY 1),
    TABLE_NAME VARCHAR2(128) NOT NULL,
    OPERATION VARCHAR2(10) NOT NULL, -- INSERT, UPDATE, DELETE
    USER_NAME VARCHAR2(128),
    TIMESTAMP_CREATED TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    OLD_VALUES CLOB,
    NEW_VALUES CLOB,
    SQL_STATEMENT CLOB,
    SESSION_ID VARCHAR2(100),
    OS_USER VARCHAR2(100),
    IP_ADDRESS VARCHAR2(45),
    CONSTRAINT PK_AUDIT_LOG PRIMARY KEY (LOG_ID, TIMESTAMP_CREATED)
)
PARTITION BY RANGE (TIMESTAMP_CREATED)
INTERVAL (INTERVAL '1' MONTH) (
    PARTITION P_INITIAL VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD'))
)
TABLESPACE USERS
ENABLE ROW MOVEMENT;

-- ==========================================
-- 6. COMPOSITE PARTITIONING (RANGE-HASH)
-- ==========================================
CREATE TABLE ORDER_DETAILS (
    ORDER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 10000 INCREMENT BY 1),
    ORDER_DATE DATE NOT NULL,
    CUSTOMER_ID NUMBER NOT NULL,
    PRODUCT_ID NUMBER NOT NULL,
    QUANTITY NUMBER DEFAULT 1,
    UNIT_PRICE NUMBER(10,2) NOT NULL,
    DISCOUNT_PERCENT NUMBER(5,2) DEFAULT 0,
    LINE_TOTAL AS (QUANTITY * UNIT_PRICE * (1 - DISCOUNT_PERCENT/100)) VIRTUAL,
    ORDER_STATUS VARCHAR2(20) DEFAULT 'PENDING',
    SHIPPING_ADDRESS CLOB,
    SPECIAL_INSTRUCTIONS CLOB,
    CREATED_BY VARCHAR2(100),
    CREATED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    UPDATED_AT TIMESTAMP(6),
    CONSTRAINT PK_ORDER_DETAILS PRIMARY KEY (ORDER_ID, ORDER_DATE, CUSTOMER_ID)
)
PARTITION BY RANGE (ORDER_DATE)
SUBPARTITION BY HASH (CUSTOMER_ID) SUBPARTITIONS 4 (
    PARTITION P_2024_Q1 VALUES LESS THAN (TO_DATE('2024-04-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q2 VALUES LESS THAN (TO_DATE('2024-07-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q3 VALUES LESS THAN (TO_DATE('2024-10-01', 'YYYY-MM-DD')),
    PARTITION P_2024_Q4 VALUES LESS THAN (TO_DATE('2025-01-01', 'YYYY-MM-DD')),
    PARTITION P_FUTURE VALUES LESS THAN (MAXVALUE)
)
TABLESPACE USERS
ENABLE ROW MOVEMENT;

-- ==========================================
-- 7. INTERVAL-HASH COMPOSITE (Target style)
-- ==========================================
CREATE TABLE TRANSACTION_LOG (
    TRANSACTION_ID NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 20000 INCREMENT BY 1),
    TRANSACTION_DATE TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    ACCOUNT_ID NUMBER NOT NULL,
    TRANSACTION_TYPE VARCHAR2(50) NOT NULL,
    AMOUNT NUMBER(15,2) NOT NULL,
    CURRENCY VARCHAR2(3) DEFAULT 'USD',
    DESCRIPTION VARCHAR2(500),
    REFERENCE_NUMBER VARCHAR2(100),
    STATUS VARCHAR2(20) DEFAULT 'PENDING',
    PROCESSED_BY VARCHAR2(100),
    AUTHORIZATION_CODE VARCHAR2(50),
    MERCHANT_ID VARCHAR2(50),
    CARD_DETAILS BLOB,
    AUDIT_TRAIL CLOB,
    CREATED_AT TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
    UPDATED_AT TIMESTAMP(6),
    CONSTRAINT PK_TRANSACTION_LOG PRIMARY KEY (TRANSACTION_ID, TRANSACTION_DATE, ACCOUNT_ID)
)
PARTITION BY RANGE (TRANSACTION_DATE)
INTERVAL (INTERVAL '1' DAY)
SUBPARTITION BY HASH (ACCOUNT_ID) SUBPARTITIONS 8 (
    PARTITION P_INITIAL VALUES LESS THAN (TO_DATE('2024-01-01', 'YYYY-MM-DD'))
)
TABLESPACE USERS
ENABLE ROW MOVEMENT;

-- ==========================================
-- CREATE COMPREHENSIVE INDEXES
-- ==========================================

-- Reference table indexes (non-partitioned)
CREATE INDEX IDX_REGIONS_CODE ON REGIONS (REGION_CODE);
CREATE INDEX IDX_REGIONS_COUNTRY ON REGIONS (COUNTRY_CODE, IS_ACTIVE);
CREATE INDEX IDX_REGIONS_ACTIVE ON REGIONS (IS_ACTIVE, CREATED_DATE);

CREATE INDEX IDX_PRODUCTS_CATEGORY ON PRODUCTS (CATEGORY, IS_ACTIVE);
CREATE INDEX IDX_PRODUCTS_PRICE ON PRODUCTS (UNIT_PRICE, CATEGORY);
CREATE INDEX IDX_PRODUCTS_CODE ON PRODUCTS (UPPER(PRODUCT_CODE));
-- Composite index for product searches
CREATE INDEX IDX_PRODUCTS_COMPOSITE ON PRODUCTS (CATEGORY, UNIT_PRICE, IS_ACTIVE);
-- Function-based index (Oracle syntax - no WHERE clause in CREATE INDEX)
CREATE INDEX IDX_PRODUCTS_MARGIN ON PRODUCTS ((UNIT_PRICE - COST) / COST);

CREATE INDEX IDX_SALES_REPS_REGION ON SALES_REPS (REGION_ID, IS_ACTIVE);
CREATE INDEX IDX_SALES_REPS_EMAIL ON SALES_REPS (UPPER(EMAIL));
CREATE INDEX IDX_SALES_REPS_HIRE ON SALES_REPS (HIRE_DATE, COMMISSION_RATE);
-- Composite index for rep lookups
CREATE INDEX IDX_SALES_REPS_COMPOSITE ON SALES_REPS (REGION_ID, IS_ACTIVE, COMMISSION_RATE);

CREATE INDEX IDX_CUSTOMERS_REGION ON CUSTOMERS (REGION_ID, CUSTOMER_TYPE);
CREATE INDEX IDX_CUSTOMERS_REP ON CUSTOMERS (ASSIGNED_REP_ID, IS_ACTIVE);
CREATE INDEX IDX_CUSTOMERS_TYPE ON CUSTOMERS (CUSTOMER_TYPE, CREDIT_LIMIT);
-- Composite index for customer searches
CREATE INDEX IDX_CUSTOMERS_COMPOSITE ON CUSTOMERS (REGION_ID, CUSTOMER_TYPE, IS_ACTIVE);
-- Function-based index for case-insensitive search
CREATE INDEX IDX_CUSTOMERS_NAME_UPPER ON CUSTOMERS (UPPER(COMPANY_NAME));

-- Partitioned table indexes
-- Local indexes (inherit partitioning)
CREATE INDEX IDX_SALES_PRODUCT ON SALES_HISTORY (PRODUCT_ID) LOCAL;
CREATE INDEX IDX_SALES_CUSTOMER ON SALES_HISTORY (CUSTOMER_ID) LOCAL;
CREATE INDEX IDX_SALES_REP ON SALES_HISTORY (SALES_REP_ID) LOCAL;
CREATE INDEX IDX_SALES_TYPE ON SALES_HISTORY (SALE_TYPE, PAYMENT_METHOD) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_SALES_ANALYSIS ON SALES_HISTORY (SALE_TYPE, TOTAL_AMOUNT, SALE_DATE) LOCAL;
CREATE INDEX IDX_SALES_CUSTOMER_DATE ON SALES_HISTORY (CUSTOMER_ID, SALE_DATE, TOTAL_AMOUNT) LOCAL;
-- Function-based local index
CREATE INDEX IDX_SALES_NET_AMOUNT ON SALES_HISTORY (TOTAL_AMOUNT * (1 - DISCOUNT_PERCENT/100)) LOCAL;

CREATE INDEX IDX_CUSTREG_CUSTOMER ON CUSTOMER_REGIONS (CUSTOMER_ID) LOCAL;
CREATE INDEX IDX_CUSTREG_STATUS ON CUSTOMER_REGIONS (STATUS, REGISTRATION_DATE) LOCAL;
CREATE INDEX IDX_CUSTREG_CURRENCY ON CUSTOMER_REGIONS (CURRENCY_CODE, CREDIT_RATING) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_CUSTREG_ANALYSIS ON CUSTOMER_REGIONS (STATUS, CREDIT_RATING, CURRENCY_CODE) LOCAL;
CREATE INDEX IDX_CUSTREG_EMAIL_UPPER ON CUSTOMER_REGIONS (UPPER(LOCAL_EMAIL)) LOCAL;

CREATE INDEX IDX_SESSIONS_LOGIN ON USER_SESSIONS (LOGIN_TIME) LOCAL;
CREATE INDEX IDX_SESSIONS_IP ON USER_SESSIONS (IP_ADDRESS) LOCAL;
CREATE INDEX IDX_SESSIONS_DEVICE ON USER_SESSIONS (DEVICE_TYPE, IS_MOBILE) LOCAL;
-- Composite local index for session analysis
CREATE INDEX IDX_SESSIONS_ANALYSIS ON USER_SESSIONS (USER_ID, LOGIN_TIME, DEVICE_TYPE) LOCAL;

CREATE INDEX IDX_AUDIT_TABLE ON AUDIT_LOG (TABLE_NAME, OPERATION) LOCAL;
CREATE INDEX IDX_AUDIT_USER ON AUDIT_LOG (USER_NAME, TIMESTAMP_CREATED) LOCAL;
CREATE INDEX IDX_AUDIT_SESSION ON AUDIT_LOG (SESSION_ID, OPERATION) LOCAL;
-- Composite local index for audit analysis
CREATE INDEX IDX_AUDIT_ANALYSIS ON AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, TIMESTAMP_CREATED) LOCAL;

CREATE INDEX IDX_ORDER_STATUS ON ORDER_DETAILS (ORDER_STATUS, ORDER_DATE) LOCAL;
CREATE INDEX IDX_ORDER_PRODUCT ON ORDER_DETAILS (PRODUCT_ID) LOCAL;
CREATE INDEX IDX_ORDER_CUSTOMER ON ORDER_DETAILS (CUSTOMER_ID) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_ORDER_ANALYSIS ON ORDER_DETAILS (ORDER_STATUS, CUSTOMER_ID, ORDER_DATE) LOCAL;
CREATE INDEX IDX_ORDER_VALUE ON ORDER_DETAILS (UNIT_PRICE, QUANTITY, DISCOUNT_PERCENT) LOCAL;

CREATE INDEX IDX_TRANS_TYPE ON TRANSACTION_LOG (TRANSACTION_TYPE, TRANSACTION_DATE) LOCAL;
CREATE INDEX IDX_TRANS_STATUS ON TRANSACTION_LOG (STATUS, ACCOUNT_ID) LOCAL;
CREATE INDEX IDX_TRANS_CURRENCY ON TRANSACTION_LOG (CURRENCY, AMOUNT) LOCAL;
-- Composite local indexes
CREATE INDEX IDX_TRANS_ANALYSIS ON TRANSACTION_LOG (TRANSACTION_TYPE, STATUS, CURRENCY) LOCAL;
CREATE INDEX IDX_TRANS_ACCOUNT_DATE ON TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_DATE, AMOUNT) LOCAL;

-- Global indexes (span all partitions) - use sparingly
CREATE INDEX IDX_SALES_AMOUNT_GLOBAL ON SALES_HISTORY (TOTAL_AMOUNT) GLOBAL 
    PARTITION BY RANGE (TOTAL_AMOUNT) (
        PARTITION P_LOW VALUES LESS THAN (1000),
        PARTITION P_MED VALUES LESS THAN (10000), 
        PARTITION P_HIGH VALUES LESS THAN (MAXVALUE)
    );

CREATE INDEX IDX_CUSTREG_CUSTOMER_GLOBAL ON CUSTOMER_REGIONS (CUSTOMER_ID) GLOBAL;

-- ==========================================
-- CREATE COMPREHENSIVE SAMPLE DATA
-- ==========================================

-- Sample data for REGIONS
INSERT ALL
    INTO REGIONS (REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES ('US', 'United States', 'USA')
    INTO REGIONS (REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES ('CA', 'Canada', 'CAN')  
    INTO REGIONS (REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES ('UK', 'United Kingdom', 'GBR')
    INTO REGIONS (REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES ('DE', 'Germany', 'DEU')
    INTO REGIONS (REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES ('JP', 'Japan', 'JPN')
    INTO REGIONS (REGION_CODE, REGION_NAME, COUNTRY_CODE) VALUES ('AU', 'Australia', 'AUS')
SELECT * FROM dual;

-- Sample data for PRODUCTS  
INSERT ALL
    INTO PRODUCTS (PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST) 
    VALUES ('ELEC-001', 'Wireless Headphones Premium', 'ELECTRONICS', 299.99, 150.00)
    INTO PRODUCTS (PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES ('ELEC-002', 'Smartphone Case Deluxe', 'ELECTRONICS', 49.99, 15.00)
    INTO PRODUCTS (PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES ('BOOK-001', 'Oracle Database Administrator Guide', 'BOOKS', 89.99, 25.00)
    INTO PRODUCTS (PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES ('HOME-001', 'Smart Home Security System', 'HOME', 599.99, 300.00)
    INTO PRODUCTS (PRODUCT_CODE, PRODUCT_NAME, CATEGORY, UNIT_PRICE, COST)
    VALUES ('SPRT-001', 'Professional Tennis Racket', 'SPORTS', 199.99, 80.00)
SELECT * FROM dual;

-- Sample data for SALES_REPS
INSERT ALL
    INTO SALES_REPS (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES ('EMP001', 'John', 'Smith', 'john.smith@company.com', '+1-555-0001', 1, 0.06)
    INTO SALES_REPS (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)  
    VALUES ('EMP002', 'Jane', 'Doe', 'jane.doe@company.com', '+1-555-0002', 1, 0.05)
    INTO SALES_REPS (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES ('EMP003', 'Alice', 'Johnson', 'alice.johnson@company.com', '+44-20-7000-0003', 3, 0.055)
    INTO SALES_REPS (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES ('EMP004', 'Bob', 'Wilson', 'bob.wilson@company.com', '+49-30-0000-0004', 4, 0.05)
    INTO SALES_REPS (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE, REGION_ID, COMMISSION_RATE)
    VALUES ('EMP005', 'Yuki', 'Tanaka', 'yuki.tanaka@company.com', '+81-3-0000-0005', 5, 0.07)
SELECT * FROM dual;

-- Sample data for CUSTOMERS  
INSERT ALL
    INTO CUSTOMERS (CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES ('CUST001', 'Acme Corporation', 'Tom Anderson', 'tom@acme.com', '+1-555-1001', 1, 1, 'PREMIUM', 50000)
    INTO CUSTOMERS (CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES ('CUST002', 'TechStart Inc', 'Sarah Connor', 'sarah@techstart.com', '+1-555-1002', 1, 2, 'STANDARD', 25000)
    INTO CUSTOMERS (CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT) 
    VALUES ('CUST003', 'British Innovations Ltd', 'James Bond', 'james@british-inn.co.uk', '+44-20-7001-0003', 3, 3, 'PREMIUM', 75000)
    INTO CUSTOMERS (CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES ('CUST004', 'Deutsche Solutions GmbH', 'Hans Mueller', 'hans@deutsche-sol.de', '+49-30-0001-0004', 4, 4, 'STANDARD', 30000)
    INTO CUSTOMERS (CUSTOMER_CODE, COMPANY_NAME, CONTACT_PERSON, EMAIL, PHONE, REGION_ID, ASSIGNED_REP_ID, CUSTOMER_TYPE, CREDIT_LIMIT)
    VALUES ('CUST005', 'Tokyo Enterprises', 'Akira Sato', 'akira@tokyo-ent.jp', '+81-3-0001-0005', 5, 5, 'PREMIUM', 100000)
SELECT * FROM dual;

-- Sample data for SALES_HISTORY (with foreign key relationships)
INSERT ALL
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER) 
    VALUES (1000, 10000, 100, DATE '2023-06-15', 5, 299.99, 1499.95, 10, 'REGULAR', 'CREDIT', 'ORD-2023-001')
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1001, 10001, 101, DATE '2024-02-10', 10, 49.99, 499.90, 5, 'BULK', 'WIRE', 'ORD-2024-001') 
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1002, 10002, 102, DATE '2024-05-20', 3, 89.99, 269.97, 0, 'REGULAR', 'CREDIT', 'ORD-2024-002')
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1003, 10003, 103, DATE '2024-08-12', 1, 599.99, 599.99, 0, 'PROMOTION', 'CHECK', 'ORD-2024-003')
    INTO SALES_HISTORY (PRODUCT_ID, CUSTOMER_ID, SALES_REP_ID, SALE_DATE, QUANTITY, UNIT_PRICE, TOTAL_AMOUNT, DISCOUNT_PERCENT, SALE_TYPE, PAYMENT_METHOD, ORDER_NUMBER)
    VALUES (1004, 10004, 104, DATE '2024-11-03', 2, 199.99, 399.98, 15, 'CLEARANCE', 'CASH', 'ORD-2024-004')
SELECT * FROM dual;

-- Sample data for CUSTOMER_REGIONS  
INSERT ALL
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10000, 'US', 'USA', 'Tom Anderson', 'contact@acme.com', '+1-555-0123')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10002, 'UK', 'GBR', 'James Bond', 'info@british.co.uk', '+44-20-7000-0001')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE) 
    VALUES (10004, 'JP', 'JPN', 'Akira Sato', 'sales@tokyo.jp', '+81-3-0000-0001')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10003, 'DE', 'DEU', 'Hans Mueller', 'kontakt@berlin.de', '+49-30-0000-0001')
    INTO CUSTOMER_REGIONS (CUSTOMER_ID, REGION_CODE, COUNTRY_CODE, LOCAL_CONTACT_NAME, LOCAL_EMAIL, LOCAL_PHONE)
    VALUES (10001, 'AU', 'AUS', 'Sarah Connor', 'hello@sydney.com.au', '+61-2-0000-0001')
SELECT * FROM dual;

-- Sample data for USER_SESSIONS
INSERT ALL  
    INTO USER_SESSIONS (SESSION_ID, USER_ID, IP_ADDRESS, USER_AGENT, IS_MOBILE, DEVICE_TYPE)
    VALUES ('sess_' || LPAD(LEVEL, 6, '0'), MOD(LEVEL, 1000) + 1, '192.168.1.' || MOD(LEVEL, 254), 'Mozilla/5.0 Chrome/95.0', 'N', 'Desktop')
SELECT * FROM dual CONNECT BY LEVEL <= 50;

-- Sample data for AUDIT_LOG
INSERT ALL
    INTO AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, OLD_VALUES, NEW_VALUES, SQL_STATEMENT)
    VALUES ('JOB_QUEUE', 'INSERT', 'APP_USER', NULL, '{"job_type":"batch","status":"pending"}', 'INSERT INTO JOB_QUEUE...')
    INTO AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, OLD_VALUES, NEW_VALUES, SQL_STATEMENT) 
    VALUES ('SESSION_DATA', 'UPDATE', 'APP_USER', '{"status":"active"}', '{"status":"expired"}', 'UPDATE SESSION_DATA...')
    INTO AUDIT_LOG (TABLE_NAME, OPERATION, USER_NAME, OLD_VALUES, NEW_VALUES, SQL_STATEMENT)
    VALUES ('APP_CACHE', 'DELETE', 'ADMIN_USER', '{"key":"temp_data"}', NULL, 'DELETE FROM APP_CACHE...')
SELECT * FROM dual;

-- Sample data for ORDER_DETAILS
INSERT ALL
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-02-15', 1001, 2001, 5, 29.99, 10, 'SHIPPED')
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-05-22', 1002, 2002, 3, 149.95, 5, 'DELIVERED') 
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-08-10', 1003, 2003, 1, 499.00, 0, 'PROCESSING')
    INTO ORDER_DETAILS (ORDER_DATE, CUSTOMER_ID, PRODUCT_ID, QUANTITY, UNIT_PRICE, DISCOUNT_PERCENT, ORDER_STATUS)
    VALUES (DATE '2024-11-05', 1004, 2004, 2, 75.50, 15, 'PENDING')
SELECT * FROM dual;

-- Sample data for TRANSACTION_LOG  
INSERT ALL
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS)
    VALUES (100001, 'PURCHASE', 45.67, 'USD', 'Online Store Purchase', 'COMPLETED')
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS)
    VALUES (100002, 'REFUND', -23.45, 'USD', 'Product Return Refund', 'COMPLETED')
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS) 
    VALUES (100003, 'TRANSFER', 1500.00, 'USD', 'Account Transfer', 'PENDING')
    INTO TRANSACTION_LOG (ACCOUNT_ID, TRANSACTION_TYPE, AMOUNT, CURRENCY, DESCRIPTION, STATUS)
    VALUES (100004, 'DEPOSIT', 2000.00, 'USD', 'Direct Deposit Salary', 'COMPLETED')
SELECT * FROM dual;

-- ==========================================
-- GATHER STATISTICS
-- ==========================================
BEGIN
    DBMS_STATS.GATHER_SCHEMA_STATS('&owner_schema');
    DBMS_OUTPUT.PUT_LINE('✓ Schema statistics gathered for &owner_schema');
END;
/

-- ==========================================
-- GRANT PERMISSIONS TO ROLES
-- ==========================================

PROMPT ========================================
PROMPT Setting up grants and roles
PROMPT ========================================

-- Grant DML permissions on all tables to DML role
DECLARE
    sql_stmt VARCHAR2(4000);
BEGIN
    FOR tab IN (SELECT table_name FROM user_tables) LOOP
        sql_stmt := 'GRANT SELECT, INSERT, UPDATE, DELETE ON ' || tab.table_name || ' TO &owner_schema._DML_ROLE';
        EXECUTE IMMEDIATE sql_stmt;
        DBMS_OUTPUT.PUT_LINE('✓ Granted DML permissions on ' || tab.table_name);
    END LOOP;
END;
/

-- Grant EXECUTE permissions on all procedures/functions/packages to EX role
DECLARE
    sql_stmt VARCHAR2(4000);
BEGIN
    FOR obj IN (SELECT object_name, object_type 
                FROM user_objects 
                WHERE object_type IN ('PROCEDURE', 'FUNCTION', 'PACKAGE', 'TYPE')) LOOP
        sql_stmt := 'GRANT EXECUTE ON ' || obj.object_name || ' TO &owner_schema._EX_ROLE';
        EXECUTE IMMEDIATE sql_stmt;
        DBMS_OUTPUT.PUT_LINE('✓ Granted EXECUTE permission on ' || obj.object_name);
    END LOOP;
END;
/

-- Grant SELECT permissions on all views to DML role
DECLARE
    sql_stmt VARCHAR2(4000);
BEGIN
    FOR view_rec IN (SELECT view_name FROM user_views) LOOP
        sql_stmt := 'GRANT SELECT ON ' || view_rec.view_name || ' TO &owner_schema._DML_ROLE';
        EXECUTE IMMEDIATE sql_stmt;
        DBMS_OUTPUT.PUT_LINE('✓ Granted SELECT permission on view ' || view_rec.view_name);
    END LOOP;
END;
/

-- Grant SELECT permissions on all sequences to DML role
DECLARE
    sql_stmt VARCHAR2(4000);
BEGIN
    FOR seq IN (SELECT sequence_name FROM user_sequences) LOOP
        sql_stmt := 'GRANT SELECT ON ' || seq.sequence_name || ' TO &owner_schema._DML_ROLE';
        EXECUTE IMMEDIATE sql_stmt;
        DBMS_OUTPUT.PUT_LINE('✓ Granted SELECT permission on sequence ' || seq.sequence_name);
    END LOOP;
END;
/

-- Grant roles to app schema
DECLARE
BEGIN
    EXECUTE IMMEDIATE 'GRANT &owner_schema._DML_ROLE TO &app_schema';
    DBMS_OUTPUT.PUT_LINE('✓ Granted &owner_schema._DML_ROLE to &app_schema');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Warning: Could not grant &owner_schema._DML_ROLE to &app_schema - ' || SQLERRM);
END;
/

DECLARE
BEGIN
    EXECUTE IMMEDIATE 'GRANT &owner_schema._EX_ROLE TO &app_schema';
    DBMS_OUTPUT.PUT_LINE('✓ Granted &owner_schema._EX_ROLE to &app_schema');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Warning: Could not grant &owner_schema._EX_ROLE to &app_schema - ' || SQLERRM);
END;
/

-- Create synonyms in app schema for all owner tables
-- Note: This would need to be run as SYSDBA or with CREATE ANY SYNONYM privilege
-- For now, just show the statements that would be needed
DECLARE
    sql_stmt VARCHAR2(4000);
BEGIN
    FOR tab IN (SELECT table_name FROM all_tables WHERE owner = '&owner_schema') LOOP
        sql_stmt := 'CREATE SYNONYM &app_schema.' || tab.table_name || ' FOR &owner_schema.' || tab.table_name;
        DBMS_OUTPUT.PUT_LINE('-- ' || sql_stmt);
        -- EXECUTE IMMEDIATE sql_stmt; -- Uncomment if running as SYSDBA
        -- DBMS_OUTPUT.PUT_LINE('✓ Created synonym for ' || tab.table_name);
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('Note: Synonym creation commented out - requires CREATE ANY SYNONYM privilege');
END;
/

PROMPT ✓ Grants and roles setup complete
PROMPT ========================================

-- ==========================================
-- VERIFICATION QUERIES
-- ==========================================
SELECT 'Table Counts:' as info FROM dual;

SELECT table_name, 
       partitioned,
       num_rows
FROM user_tables 
WHERE table_name IN ('SALES_HISTORY', 'CUSTOMER_REGIONS', 'USER_SESSIONS', 
                     'AUDIT_LOG', 'ORDER_DETAILS', 'TRANSACTION_LOG',
                     'APP_CACHE', 'JOB_QUEUE', 'SESSION_DATA', 'TEMP_CALCULATIONS')
ORDER BY table_name;

SELECT 'Partition Information:' as info FROM dual;

SELECT table_name,
       partitioning_type,
       subpartitioning_type, 
       partition_count,
       def_subpartition_count,
       interval
FROM user_part_tables
ORDER BY table_name;

SELECT 'Identity Column Information:' as info FROM dual;

SELECT table_name,
       column_name, 
       generation_type,
       sequence_name
FROM user_tab_identity_cols
ORDER BY table_name, column_name;

COMMIT;

-- ==========================================
-- FINAL SUMMARY AND CONNECTION INFO
-- ==========================================

PROMPT ====================================
PROMPT Oracle Comprehensive Test Environment
PROMPT Setup Complete!
PROMPT ====================================
PROMPT 
PROMPT Schemas Created:
PROMPT - Owner Schema: &owner_schema (password: &owner_password)
PROMPT - App Schema:   &app_schema (password: &app_password)
PROMPT 
PROMPT Roles Created:
PROMPT - &owner_schema._DML_ROLE (granted to &app_schema)
PROMPT - &owner_schema._EX_ROLE (granted to &app_schema)
PROMPT 
PROMPT Tables Created:
PROMPT - REGIONS (Non-partitioned reference)
PROMPT - PRODUCTS (Non-partitioned reference)
PROMPT - SALES_REPS (Non-partitioned reference)
PROMPT - CUSTOMERS (Non-partitioned reference)
PROMPT - SALES_HISTORY (Range Partitioned)
PROMPT - CUSTOMER_REGIONS (List Partitioned)  
PROMPT - USER_SESSIONS (Hash Partitioned)
PROMPT - AUDIT_LOG (Interval Partitioned)
PROMPT - ORDER_DETAILS (Range-Hash Composite)
PROMPT - TRANSACTION_LOG (Interval-Hash Composite)
PROMPT 
PROMPT Features Included:
PROMPT - Identity columns with sequences
PROMPT - Complex constraints (PK, FK, UK, CK)
PROMPT - Comprehensive indexes (local, global, composite, function-based)
PROMPT - All Oracle partitioning types
PROMPT - CLOB and BLOB columns
PROMPT - Virtual columns
PROMPT - Referential integrity chains
PROMPT 
PROMPT Connection Examples:
PROMPT - Owner: sqlplus &owner_schema/&owner_password@your_database
PROMPT - App:   sqlplus &app_schema/&app_password@your_database
PROMPT 
PROMPT ====================================
PROMPT Ready for Oracle Table Migration Testing!
PROMPT Use this for discovery: --schema &owner_schema
PROMPT ====================================

-- Enable DBMS_OUTPUT for future sessions
SET SERVEROUTPUT ON