# Oracle Table Migration - Repository Instructions

## ðŸ“š **Project Organization - START HERE**

**ðŸŽ¯ New Users:** Read the main `README.md` first for quick start

**ðŸ“Š Architecture:** Clean, simplified structure with single entry point `src/generate.py`

**ðŸ”„ Development:** Use `scripts/tdd-migration-loop.sh` for iterative development

**âš¡ Quick Reference:** Run `python src/generate.py --help` for usage

## Core Development Principle
**"it should just run master1.sql, nothing else should be required"**

This principle drives ALL development decisions. Any **table re-partitioning migration** must be completable by executing only the master1.sql script with zero manual intervention.

**CRITICAL**: Config must be generated by real database discovery - no pre-existing or mocked configurations allowed.

## Tool Purpose: Oracle Table Re-Partitioning Migration
The whole purpose of this tool is to migrate an existing partitioned table to a differently partitioned table:

1. **Create table_new** with different partitioning strategy, constraints, indexes
2. **Optional data migration** with dynamic constraint disabling/enabling
3. **Delta loads** configurable by partition key (last day/hour) until difference is near zero
4. **Atomic rename operations**: `table â†’ table_old; table_new â†’ table` (all succeed or all fail)
5. **Validation and cleanup** with zero manual intervention

## Essential Development Workflow

### Before ANY Code Changes:
1. **Read instructions**: Check `.github/instructions/current_status.instructions.md` for latest status
2. **Validate environment**: Run `./scripts/tdd-migration-loop.sh --validate-only`
3. **Follow TDD process**: Use the 7-phase TDD loop for all development

### Development Process:
1. **Test discovery first**: `python3 src/generate.py --discover --schema SCHEMA --connection "conn_string"`
2. **Modify schema if needed**: Update `test/data/comprehensive_oracle_ddl.sql` 
3. **Iterate with TDD**: `./scripts/tdd-migration-loop.sh --generate-only --verbose`
4. **Validate completeness**: `./scripts/final-migration-test.sh --connection my_oracle_db`
5. **Update instructions**: Keep `.github/instructions/` files synchronized

### Test Success Definition:
The definition of success is that you can:
1. **Connect to real Oracle database** and run discovery successfully
2. **Generate JSON config** from existing partitioned table (discovery-driven only)
3. **Create DDL scripts** from templates using discovered config
4. **Run master1.sql** and get everything running
5. **Zero errors and zero manual intervention** required

### Critical Success Criteria:
- âœ… master1.sql executes without errors
- âœ… Create `table_new` with different partitioning strategy
- âœ… Optional data migration with constraint disabling/enabling
- âœ… Delta loads configurable by partition key (last day/hour)
- âœ… Atomic rename operations: `table â†’ table_old; table_new â†’ table`
- âœ… All constraints and indexes recreated  
- âœ… Referential integrity preserved
- âœ… Grants captured in config.json and restored
- âœ… Zero manual intervention required

## File Architecture Guidelines

### When Adding Oracle Features:
1. Add to `test/data/comprehensive_oracle_ddl.sql`
2. Update `lib/discovery_queries.py` detection logic
3. Enhance `lib/migration_models.py` enums/dataclasses
4. Update `templates/master1.sql.j2` with new functionality
5. Test with TDD loop until final validation passes

### When Fixing Re-Partitioning Issues:
1. Identify gap in `templates/master1.sql.j2`
2. Enhance template with missing functionality
3. Run `./scripts/final-migration-test.sh` until it passes
4. Never add manual steps - fix the template instead
5. Must include option to backup or drop `table_new` if it already exists

### Template System Rules:
- **master1.sql.j2** must contain complete end-to-end re-partitioning (steps 00-80)
- Use typed dataclasses for all template variables
- Apply Jinja2 filters from `lib/template_filters.py`
- Validate against comprehensive DDL schema
- **Step 50**: Atomic rename operations (no built-in atomic swap, make atomic via transaction)
- **Step 60**: Restore grants (keep dynamic_grants.sql as backup)
- **Step 70**: Generate separate drop script (NOT part of master1.sql)

## Key Components

### Primary Scripts:
- **src/generate.py**: Unified migration generator (single entry point) - discovery + generation modes
- **src/generate_scripts.py**: Reference implementation (complete discovery architecture)
- **test/runner.py**: Automated schema testing

### Test Framework:
- **scripts/tdd-migration-loop.sh**: 7-phase TDD automation
- **scripts/final-migration-test.sh**: Ultimate master1.sql validation
- **test/data/comprehensive_oracle_ddl.sql**: Complete Oracle feature test schema

### Templates:
- **templates/master1.sql.j2**: Complete migration workflow template
- **templates/validation/**: Validation query templates
- All templates support full Oracle feature set

## Corrected Workflow Steps:

### Step 10: Create partitioned table
- Create `table_new` with different partitioning strategy
- Must include option to backup or drop `table_new` if it already exists

### Conditional Data Migration:
```
if [data migration or delta load then disable constraints]
    Step 20: Data migration with validation if requested
    Step 40: Delta load if requested (configurable by partition key - like last day or last hour)
    enable constraints
    run stats 
fi
```

### Step 50: Atomic table swap  
- **No such thing as built-in atomic swap**
- Make it atomic by transaction: `table â†’ table_old; table_new â†’ table`
- All renames work or they all fail - that's what makes it atomic
- Check for invalidations from changing keys or loss of grants

### Step 60: Restore grants
- Capture grants as part of generation into config.json
- Create `dynamic_grants.sql` script as backup
- This doesn't have to be part of normal process, note it to run in case there's a problem with grants

### Step 70: Drop old table
- Just produce a SQL statement to drop
- Should NOT be part of master1.sql
- Generate as separate script for manual execution

## Database Integration:
- Use SQLcl named connections: `conn user/pass@host:port/service; save connection name`
- Support all Oracle partitioning: Range, List, Hash, Interval, Composite
- Handle constraints: PK, FK, UK, CK with referential integrity
- Manage indexes: Simple, composite, function-based, bitmap
- Capture and restore grants dynamically

## Testing Requirements:
- Always run TDD loop before committing
- Validate with comprehensive DDL (10 tables, all Oracle features)
- Ensure final-migration-test.sh passes
- Update relevant instruction files when workflows change
- Mimic sessions inserting new data and verify all works well

## Error Handling:
- Templates must include rollback capabilities
- Scripts must validate prerequisites
- All database operations must be atomic where possible
- Provide clear error messages with actionable guidance